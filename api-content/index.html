{"posts":[{"title":"Arm Performance Libraries 環境配置","content":"Arm Performance Libraries 作為 Linux 的 Arm Compiler 的一部分安裝，並且需要 Arm Allinea Studio 許可證 License Arm Allinea Studio 工具套件為在 Arm 硬體上開發 HPC 應用程式提供了完整的解決方案。 它包括： Arm C/C ++/Fortran 編譯器 ArmPL Arm Forge（Arm DDT，Arm MAP和Arm Performance Reports） 需要許可證來使用這些工具。 有兩種許可證， Named User 和 Floating 在獲得許可證後，按照以下說明將其新增到系統中： Add a named user license 在 /opt/arm/ 目錄中建立一個名為 licenses 的目錄 將許可證檔案複製到 /opt/arm/licenses 目錄；如果選擇將許可證檔案放在其他位置，則必須將 ARM_LICENSE_DIR 環境變數設定為指向它 export ARM_LICENSE_DIR=/opt/arm/licenses Arm Forge 和 Arm Performance Reports 在其特定的安裝目錄中搜索許可證。如果使用的是 Arm Allinea Studio 許可證，並且沒有為這些工具使用單獨的許可證，請設定 ALLINEA_LICENSE_DIR 環境變數以將這些工具指向您的 Arm Allinea Studio 許可證 export ALLINEA_LICENSE_DIR=/opt/arm/licenses &gt; named user license，無需安裝Arm License Server Setting up a floating license 必須下載並安裝 Arm License Server 浮動許可證由伺服器許可證檔案和客戶端許可證檔案組成，在這裡申請 檢查客戶端許可證是否包含執行Arm License Server的計算機的主機名或IP地址 將客戶端許可證新增到安裝 Arm Allinea Studio 的計算機上。在 /opt/arm 目錄中建立一個名為 licenses 的目錄 同 named 同 named 將伺服器許可證檔案新增到安裝 Arm License Server 的計算機上。在 /opt/arm/licenceserver 目錄中建立一個名為 licenses 的目錄，並將您的許可證檔案複製到該目錄中 重新啟動 Arm License Server 下載 Arm Allinea Studio downloads page 安裝 需要 python &gt;= 2.7 需要 C Libraries：SUSE and RHEL: glibc-devel Ubuntu: libc6-dev 解壓縮 tar -xvf .tar.gz cd 預設配置安裝 sudo ./.sh 可以自定義 options 安裝程式將顯示EULA並提示您同意條款 接下來主要介紹 ArmPL 的配置和使用 配置 檢視可用的環境模組 module avail 可能需要配置MODULEPATH環境變數以包含安裝目錄 export MODULEPATH=$MODULEPATH:/opt/arm/modulefiles/ 為您使用的編譯器載入適當的模組，如果使用的是用於Linux的Arm Compiler，則建議僅載入編譯器模組，如果使用gcc，則必須載入所需的特定Arm Performance Libraries模組 module load Generic-AArch64/RHEL/7/arm-linux-compiler/20.0 如果使用gcc編譯器，請確保載入正確的模組 module load Generic-AArch64/RHEL/7/gcc-9.2.0/armpl/20.0.0 Tips: 可以考慮將模組載入命令新增到您的.profile中，以在每次登入時自動執行它 根據使用的編譯器，使用以下命令檢查環境 Compiler Command armclang which armclang gcc which gcc 舉個例子 ArmPL 包含許多示例程式，如果是預設安裝的，位置在/opt/arm//examples/ 這裡以 fftw_dft_r2c_1d_c_example.c 為例，具體做什麼就不看了 編譯和連結的選項： -armpl: 與arm編譯器進行編譯和連結時 -mcpu = native: 允許編譯器從主機系統推斷要使用的庫 -L\\lib: 新增庫搜尋路徑 -larmpl_lp64: 連結到Arm Performance Libraries -lgfortran: 連結到 gcc Fortran 執行庫 -lm: 連結到標準數學庫 編譯原始碼，生成一個目標檔案 Compiler Command armclang armclang -c -armpl -mcpu=native fftw_dft_r2c_1d_c_example.c -o fftw_dft_r2c_1d_c_example.o gcc gcc -c -I/include fftw_dft_r2c_1d_c_example.c -o fftw_dft_r2c_1d_c_example.o 將目的碼連結到可執行檔案中 Compiler Command armclang armclang fftw_dft_r2c_1d_c_example.o -o fftw_dft_r2c_1d_c_example.exe -armpl -mcpu=native -lm gcc gcc fftw_dft_r2c_1d_c_example.o -L/lib -o fftw_dft_r2c_1d_c_example.exe -larmpl_lp64 -lgfortran -lm 在Arm系統上執行可執行檔案 ./fftw_dft_r2c_1d_c_example.exe 可以看到相應的輸出 Compile and test the examples examples 目錄包含以下內容： 一個GNUmakefile，用於生成和執行所有示例程式 C 原始碼 .c Fortran原始碼 .f90 每個示例的預期輸出 .expected Makefile編譯並執行每個示例，然後將生成的輸出與預期的輸出進行比較。任何差異都會標記為錯誤 ","link":"https://IsumiAlice.github.io/post/koJCJJ3ay/"},{"title":"康威生命遊戲","content":" 2020.4.11，名為 Conway 的細胞沒有足夠多的鄰居，遺憾的退出了生命遊戲 康威生命遊戲 Conway's Game of Life，又稱康威生命棋，是英國數學家約翰·何頓·康威在1970年發明的細胞自動機。 接下來我將實現一個簡單的康威生命遊戲，詳細的資料可以參考 wiki 頁面 規則 生命遊戲中，對於任意細胞，規則如下： 每個細胞有兩種狀態 - 存活或死亡，每個細胞與以自身為中心的周圍八格細胞產生互動（如圖，黑色為存活，白色為死亡） 當前細胞為存活狀態時，當周圍的存活細胞低於2個時（不包含2個），該細胞變成死亡狀態。（模擬生命數量稀少） 當前細胞為存活狀態時，當周圍有2個或3個存活細胞時，該細胞保持原樣。 當前細胞為存活狀態時，當周圍有超過3個存活細胞時，該細胞變成死亡狀態。（模擬生命數量過多） 當前細胞為死亡狀態時，當周圍有3個存活細胞時，該細胞變成存活狀態。（模擬繁殖） 可以把最初的細胞結構定義為種子，當所有在種子中的細胞同時被以上規則處理後，可以得到第一代細胞圖。按規則繼續處理當前的細胞圖，可以得到下一代的細胞圖，周而復始。 ","link":"https://IsumiAlice.github.io/post/8wQ7j8r3w/"},{"title":"物理學中的「四大神獸」","content":"為了更好地闡述自己的想法，物理學家喜歡通過講故事來進行形象的說明。物理學界的「四大神獸」便是這樣誕生的，他們分別是芝諾的烏龜、拉普拉斯獸、麥克斯韋妖和薛定諤的貓。 芝諾的烏龜 - 縮地成寸 古希臘哲學家芝諾曾講過這樣一個故事：烏龜和阿喀琉斯賽跑。阿喀琉斯身為海洋女神之子，號稱希臘第一勇士，身體強壯，奔跑速度比烏龜快十倍。賽跑時，他很有體育精神，讓烏龜先跑一百米，然後自己才發力追趕。等到他跑了一百米時，烏龜比他領先十米；等他又追了十米時，烏龜又比他領先了一米。如此反覆，阿喀琉斯什麼時候能追上這隻烏龜呢？在注重嚴密推理和嚴謹論證的物理學界，這個問題困擾了物理學家兩千年。其實單靠物理學是無法解釋清楚這個問題的，因為它涉及數學的極限概念。這個問題一直到微積分這門學科的創立才得到解決。 拉普拉斯獸 - 推演萬物 兩百年前，法國物理學家拉普拉斯根據牛頓定律，設想宇宙間存在一隻神獸，它神通廣大，無所不知，它能知道宇宙間每一個原子的位置和動量，並且會通過牛頓的物理公式計算出宇宙的過去和未來。人們管拉普拉斯設想出的這隻神獸叫拉普拉斯獸。 這隻「上知五百年，下知五百年」的神獸並沒有困擾物理學家很久。1927 年，德國物理學家海森堡提出，在微觀世界中不可能同時知道一個粒子的位置和它的速度，也就是說，粒子的狀態是不確定的，這就是「不確定性原理」。再厲害的神獸也無法知道微觀世界的全部面貌，所以即使在虛擬世界裡，洞悉萬物的神獸也是不存在的。 麥克斯韋妖 - 逆轉時空 兩個容積相同的水箱，左邊的水溫 40 攝氏度，右邊的水溫 60 攝氏度。如果兩個水箱中的水完全混合，水溫將是 50 攝氏度。英國物理學家麥克斯韋就想：為什麼不能是一個 20 攝氏度，另一個 80 攝氏度呢？1871 年，他設想出一個精靈，它能夠探測出分子運動的速度，混合冷熱不同的水之後，精靈迅速出擊，將運動慢的水分子移到左邊，再將運動快的水分子移到右邊。這樣一來，不就是左邊的水溫低，右邊的水溫高了嗎？水箱不僅左右形成了溫差，而且實現了熵的自發減少，這個精靈被人稱作麥克斯韋妖。如果這樣的精靈真實存在，就可以操控萬物，逆轉陰陽，創造永動機將成為現實，宇宙的壽命也將會變得無限長。 在 1948 年，一個新的學說——資訊熵產生了。通過這個學說，人們得知麥克斯韋妖要獲知分子運動速度，勢必損耗分子的能量。也就是說，在麥克斯韋妖探知和搬運分子的過程中，分子運動速度始終處於不確定狀態。所以，孤立系統中的麥克斯韋妖是不可能實現它的目標的。 進入21世紀，學界痴迷於研究熵減過程。2007年2月發現一種人造麥克斯韋妖，通過「資訊擒縱閥」使系統逐漸遠離平衡態，不過，這個人造麥克斯韋妖仍需要光作為能量源。 薛定諤的貓 - 超越生死 「活著還是死去？」這個問題讓哈姆雷特很頭疼。但對「薛定諤的貓」來說，這根本不是事兒，因為這隻貓可以「既死又活」。1935 年，奧地利量子力學家薛定諤提出了這樣一個設想：將一隻貓關在裝有毒藥和少量鐳的鐵盒子裡。如果鐳已經發生衰變，觸發機關打碎裝有毒藥的瓶子，貓就會死；如果鐳尚未發生衰變，貓就存活。根據量子力學理論，在人們開啟盒子觀察之前，由於放射性的鐳處於衰變和沒有衰變兩種狀態的疊加狀態，貓會處於死貓和活貓的疊加狀態，宏觀世界的因果律已經坍塌，只剩下一連串的概率波。也就是說，這隻貓既死又活。 雖然這隻貓和砸在牛頓頭上的那個蘋果一樣有名，但顯然「既死又活的貓」不像萬有引力那樣容易理解。要想認識這隻貓，我們得先了解一下什麼是量子力學。20 世紀初，一些物理學家共同創立了量子力學，他們認為微觀世界和巨集觀世界有著很大的不同。比如粒子可以存在於疊加狀態中，能同時擁有兩個相反的特性。舉例來說：生活中我們常說「不是在咖啡館就是在去咖啡館的路上」，而在量子力學看來，粒子是可以處於「既在咖啡館又在路上」的狀態。 雖然薛定諤創造這隻神獸僅是為了方便吃瓜群眾們從巨集觀尺度理解量子物理，但它很快成了大家的噩夢，1957年，埃弗萊特用「多世界理論」給這隻貓找到了歸宿。他認為，問題並不在於盒子中的放射性原子是否衰變，而在於它既衰變又不衰變。薛定諤之貓是條活生生的生命，在它被觀測那一刻，世界分裂成了兩個版本，在A版本中，貓活著，而B版本中，貓死去。然而，儘管「多世界理論」非常優美，卻被哥本哈根派這個量子力學頭號教派極力打壓，遂鮮為人知。所以，這隻可憐的貓咪，依舊遊蕩在人界、地獄之間的灰色空間。 物理學中的四大神獸，分別以形象生動的方式闡明瞭各自提出者的想法，從而引起了人們的極大興趣。雖然在物理學發展的過程中，有些神獸的「超能力」被證明不可能存在，但是它們也以自己的方式推動了物理學的發展。 來源: https://www.zhihu.com/market/paid_magazine/1200885042401345536/section/1200885107052359680 ","link":"https://IsumiAlice.github.io/post/3zf3BZtNm/"},{"title":"部落格 log","content":"2020-4-22 21:27:57 添加一個殘廢的搜索功能😎 2020-04-10 20:06:24 已經...不想再折騰了... 從 Hexo 遷移到 Gridea 剩下的事情明天再做👻 ","link":"https://IsumiAlice.github.io/post/hegridea/"},{"title":"Ray Tracing in a Weekend","content":"首先, 關於為什麽使用 C++, 因為 Python 太慢了而且直接抄原作者的程式碼多香啊這裡直接貼程式碼截圖, 因為原作者的程式碼段在修改位置有高亮, 方便閱讀 1. 輸出影像 直接採用一個純文字的 PPM 檔案, 畫素資訊從左至右從上至下的方式輸出可以使用 PPM Viewer 讀取書中給出的程式碼直接將資料打印出來, 這裡我改為直接寫入一個 PPM 檔案中輸出: 2. 3D Vector Class 一個簡單的向量操作 Class, 包含了向量的加減, 點乘, 叉乘, 標準化...程式碼就不貼了使用 vec3 類重寫上一節的程式 3. Rays, a simple camera, and background ray class其中 A 表示射線起點, B 表示方向, point_at_parameter 可以根據給定的 t 返回支線AB上任意位置的三維座標座標系設定世界座標系和觀察平面, 攝像機位置在世界座標系原點, 螢幕座標以左下角為原點, (u, v) 表示螢幕上畫素點的位置(數值標準化到 0 1 區間)修改 main 函式, 新增 4 個 vec3, 分別表示螢幕的左下角, 螢幕寬度, 螢幕高度, 相機位置**天空背景: **採用 color 函式來計算每個畫素的顏色, 相當於一個 RayGeneration Shader, 對於每條射線, 計算輸出的顏色並返回主程式 4. 添加一個球 因為球的求交容易, 所以從球開始計算公式很簡單, 略通過 hit_sphere 來進行 hit 檢測, 也相當於一個 Shader, 一條光纖和球可能有 012 個交點如果 hit, 則返回紅色, 因此可以得到一個紅色的無立體感的球 5. 表面法線與多個物件 前一節略的公式可以計算出球和光線相交位置的 t 值, 從而得到 hit 的三維座標, 因為是處理球體, hit 處的法線可以直接通過球心和 hit 位置的兩個座標得到hit_sphere 不再返回是否有 hit, 而是返回 hit 的位置將法向量的值作為 hit 位置的顏色輸出hit_record, 引數 t 和 p 均表示 hit 的位置, normal 是法向量接下來將球體的程式碼抽象出來, 實現一個 hitable 類, 具有虛擬函式 hit, 輸入光線 r, 最小取樣距離 t_min, 最大采樣距離 t_max, hit_record 的引用 &amp;recsphere 類, 引數為球心和半徑sphere::hit, 如果有交點那麼用求根公式算出較小的根, 如果在取樣範圍內, 則寫入 &amp;rec, 否則計算較大的根為了處理多個物體, 採用一個hitable_list, 儲存一個 hitable 指標陣列及其大小hitable_list 也可以被碰撞檢測, temp_rec 記錄最後 hit 的資訊, hit_anything 表示是否有 hit, closest_so_far 記錄最近的 hit 位置然後迴圈對列表中的每個可 hit 物體進行檢測, 取樣射線 r 保持, 最小取樣距離不變, 最大距離不斷更新為closest_so_far更新main和color函式, color添加了一個可撞擊物的引數, 聲明瞭撞擊記錄變數, 後面的法向量就是從記錄中獲取的, 取樣最大距離初始化為浮點數最大值main函式聲明瞭兩個球組成的 list, 然後構造為 hitable_list 物件輸出: 6. 反鋸齒 為什麼會有鋸齒？採用蒙特卡洛方法對單個畫素內的區域進行隨機取樣, 然後得到 color 取均值順帶將攝像機位置抽象為一個 class:更新 main: 可以看到邊緣處的顏色得到了處理 7. 漫反射 Diffuse Materials 將我們的球球假設為理想的朗博體, 處理方法是在 hit 處的表面發現方向, 做一個半徑為 1 的單位球, 在球內隨機取點, 作為反射的方向color 採用 target 反射的位置, 不再返回法向量的值, 程式碼中的那句遞迴, 就是光線追蹤啊！當前處理的射線由其入射方向的顏色乘以一個衰減係數 0.5 得到, 表示物體吸收了一部分光, 直到入射光線沒有任何 hit 即是來自環境的光照（天空色）後續的其他材質處理, 都是在此基礎上改變 color 的輸出輸出的的效果比較暗, 但已經是一個有立體感的球了, 畢竟我們還沒有加入更真實的物理因素, 只是單純的將顏色乘以 0.5太黑了, 所以採用 gamma 矯正來提高亮度（對得到的顏色開平方, 因為值都是01之間, 所以開方後會變大） 8. 金屬 Metal 先把上一節的內容抽象為一個 material class, 四個引數, hit in 射線, hit record（因為先檢測碰撞再考慮材質）, 衰減率, 下一步的取樣方向（折射、反射或其他）hit record 增加對材質的記錄上一節的朗伯體:這一節主要考慮光滑表面的反射反射公式就是一個向量加法金屬材質, 調用反射公式, 引數 albedo 表示反射率color的計算, 新增一個迭代深度防止死迴圈main中新增兩個金屬球金屬也是多種多樣的, 有的鏡面反射也帶著漫反射, 處理這種材質, 在反射的終點做一個球, 在球內隨機取點, 這樣反射後就從一條光線變為一束光線了程式碼中透過 fuzz 變數控制反射範圍的大小, 最大為單位球考慮了反射加漫射的效果, 左側 fuzz=0.3, 右側 fuzz=1.0 9. 電介質 Dielectrics 這一節主要考慮電介質, 指帶折射的材料, 光從一側進入從另一側射出, 如水, 玻璃等Snell 折射定律 折射公式, 引數為入射向量, 法向量, n/n', 折射向量判別式 的計算有點意思, 略如果判別式大於 0, 表示有折射發生, 進而計算折射向量 refracted（簡單的三角函式, 略）電介質 class, 新增 ref_idx 引數表示折射率散射函式 scatter, 輸入入射光線 r_in, 衰減率 attenuation, 輸出出射光 scattered內定義了一個 outward_normal先計算反射向量 reflected再計算折射向量 refracted第一個 if 判斷 dot 的結果, 如果在 90 度內, 表示是從材質內部射向空氣的光線, 將法向量取反否則表示從空氣射入電介質的光線第二個 if 判斷是否發生折射, 如果有折射則輸出設定為折射光, 否則設定為反射光場景物件列表目前處理的情況過於簡單, 有折射就不要反射了呢~實際上光的傳輸是能量守恆的, 所以可以通過一個比率來控制折射和反射的能量, 比率通過菲涅爾公式得到, 這個比率和材質以及攝入的角度有關實際使用中採用 schlick 公式來近似菲尼爾曲線更新電介質 material, 若折射, 則計算一個比率, 否則反射比率為 1採用一個隨機數來判斷當前處理的光線到底該折射還是反射, 因為多次取樣求平均, 所以不用同時追蹤兩條光線新增一個球, 球心和左球重合, 半徑為負, 因此法向量也是負數, 相當於把左球再翻轉一次, 從而得到一個透明玻璃球的特效 10. 改變相機位置 是時候把 main 函式中的 camera 也抽象出來了, 相機可以看作一個四稜錐, 渲染它的切面先給 camera 新增兩個引數, theta角度和寬高比, 根據角度計算出螢幕高度, 然後得出寬度, 其他向量都跟著改變接下來讓 camera 旋轉起來, Vup 一般是一個全域性向量 (0,1,0), 另外三個軸 uvw 負責選擇再向 camera class 中新增 lookfrom, lookat, 根據兩個點確定 -w 這個觀察方向, 然後計算出 u 和 vmain中修改視點: 11. 景深 相機分為三部分, 感光膠片, 透鏡, 成像平面, inside 決定聚焦, outside 決定散焦, 因此模擬 outside 部分觀察點從一個點改為一個給定尺寸的三維圓, 射線在園內隨機位置射出隨機函式camera class添加了光圈大小 aperture, 焦距 focus dist 不再固定為 1配置一下方向和大光圈輸出: End 書中最終程式碼渲染的結果跑了四分鐘( 笑 ) ","link":"https://IsumiAlice.github.io/post/NkOR8gf_w/"},{"title":"使用 Windows 時經常遇到的問題","content":"更換主機板 如果拆不下散熱器和主機板的螺絲，就用力一點！！！ 主機板的電源綫要插牢固 OneDrive 右鍵釋放空間 簡單的方法可以把使用者賬戶控制設為預設值 如果上面的方法失敗： win+r -&gt; gpedit.msc 打開本機群組原則編輯器 重啓 更換主硬盤遷移系統 PartAssist.exe，很好用 睡眠問題 睡眠後螢幕關閉，但滑鼠亮著，機箱風扇也在工作 解決方法：把登録編輯程式的 AwayModeEnable 設定為 0 位置在：電腦\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Power 如果Windows無法安裝到指定磁盤 shift+F10 diskpart list disk select disk Clean 若需要 convert mbr 卓越性能模式 管理員運行 Windows Powershell powercfg -duplicatescheme e9a42b02-d5df-448d-aa00-03f14749eb61 應用程式自啓動 windows - 執行(run) - shell:startup - 確定 - 將要開機啓動的程式捷徑放入即可 禁用筆電自帶的鍵盤 設備管理器 鍵盤-PS/2 右鍵-更新驅動 瀏覽計算機查找驅動 從計算機的驅動列表選擇 取消選擇-顯示兼容硬體 隨便選一個其他品牌驅動 是-重啓 ","link":"https://IsumiAlice.github.io/post/RHud701ar/"},{"title":"Raspberry 配置 ASF","content":"首先在國內網路下要保證配置好了代理服務 (參見之前的 Raspberry Hello) ASF Git 頁面: https://github.com/JustArchiNET/ArchiSteamFarm Setting up 頁面: https://github.com/JustArchiNET/ArchiSteamFarm/wiki/Setting-up-zh-CN 在 release 頁面下載相應壓縮檔, 一般來說選 linux-arm 安裝相關依賴 套件名稱取決於您正在使用的 Linux 發行版，我們已經列出了最常見的套件。 您可以使用本地套件管理系統，為您的作業系統取得全部套件（例如 Debian 的 apt 或 CentOS 的 yum）。 libcurl（libcurl4、libcurl3） libicu（您的 Linux 發行版的最新版本，例如 libicu60） libkrb5-3（krb5-libs） liblttng-ust0（lttng-ust） libssl（libssl1.1、openssl-libs、您的 Linux 發行版最新的 1.1.X 版本） zlib1g（zlib） 其中至少應該有幾個套件已經可用於您的系統本地了（例如現今幾乎每一個 Linux 發行版都需要 zlib1g）。 配置 在 網頁設定檔產生器 頁面配置一個 ASF 和一個 Bot 然後放入 config 資料夾中 修改權限 chmod +x ArchiSteamFarm 然後 ./ArchiSteamFarm 執行 若需要代理則在前面添加 proxychains ","link":"https://IsumiAlice.github.io/post/GcP6XkwG6/"},{"title":"Raspberry 基礎配置","content":"寫入系統到存儲卡中 在通電前, 要先把系統搞定 官方下載站: http://www.raspberrypi.org/downloads 格式化工具: SDFormatter 寫入工具: Win32DiskImager 注意寫入過程中不要點格式化 默認登入名為 pi, pw: raspberry root pw: raspberry 硬體裝配 把主板從盒子取出來 插入裝有系統的存儲卡 連接電源, HDMI, 網綫, 鍵鼠 插入電源後即直接進入系統 系統配備 以下配備均是在官方系統下操作的 root 由pi用戶登録後 sudo passwd root sudo passwd --unlock root 更換為國內 source sudo nano /etc/apt/sources.list 添加 deb http://mirrors.aliyun.com/raspbian/raspbian/ buster main contrib non-free rpi deb-src http://mirrors.aliyun.com/raspbian/raspbian/ buster main contrib non-free rpi 更新 sudo apt-get update 配置中文 安裝中文字庫 sudo apt-get install ttf-wqy-zenhei 輸入法 sudo apt-get install fcitx fcitx-googlepinyin fcitx-module-cloudpinyin fcitx-sunpinyin 配置中文 sudo raspi-config - 4 Localisation - I1 Change Locale 選擇 zh_CN GB2312, zh_CN.GB18030 GB18030, zh_CN.GBK GBK, zh_CN.UTF-8 UTF-8, zh_CN.UTF-8 Enter - sudo reboot 重啓後打開設置, Localisation - SetLocal - CharacterSet - GB18030 - OK 之後會提示重啓 - Yes 配置中文輸入法 Fcitx配置 - 左下角加好 - 選擇需要的 固定 IP sudo nano /etc/dhcpcd.conf 然後自己看着辦 開啓 SSH sudo raspi-config - Interfacing Options - SSH 系統備份, 還原 在 Windows 下可以創建一個空的.img資料, 然後插入存儲卡, 使用 Win32 Disk Imager 的 Read 功能. 會將整張卡進行備份. 配置代理服務 安裝 SS sudo apt-get install shadowsocks or sudo pip install shadowsocks 配置 SS 參數 sudo vi /etc/shadowsocks/config.json { &quot;server&quot;: , &quot;server_port&quot;: , &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;: &quot;1080&quot;, &quot;password&quot;: , &quot;timeout&quot;: 300, &quot;method&quot;: &quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false, &quot;workers&quot;: 1 } 啓動 apt-get sudo /usr/bin/sslocal -c /etc/shadowsocks/config.json -d start pip sudo /usr/local/bin/sslocal -c /etc/shadowsocks/config.json -d start 開機啓動 su vim /etc/rc.local 最後的 exit 0 的上一行添加 sudo /usr/bin/sslocal -c /etc/shadowsocks/config.json -d start 不同方式安裝的 sslocal 位置可能不同, which sslocal 配置瀏覽器代理 下載 SwitchyOmega https://github.com/FelisCatus/SwitchyOmega/releases 打開瀏覽器拓展頁面 chrome://extensions 并拖入 若出現錯誤, 打開瀏覽器頁面右上角開發者模式, 然後解壓縮 release 的包, 瀏覽器中選擇加載已解壓的拓展 配置 SwitchyOmega 的方法 左側 proxy, 修改為 SOCKS5, 127.0.0.1, 1080 auto switch, 添加規則 https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt 配置終端代理 使用 proxychains 執行相應命令 sudo apt install proxychains4 sudo vi /etc/proxychains.conf 最後一行添加 socks5 127.0.0.1 1080 并刪除多餘內容 proxychains curl www.google.com 一些基本操作 Neofetch 顯示系統信息 sudo apt-get install neofetch neofetch 可以修改 ~/.config/neofetch/config.conf 自定義輸出信息 獲取溫度 cd /sys/class/thermal/thermal_zone0 cat temp 返回值除以 1000 即為當前 CPU 溫度 設置時區 date 查詢系統時間 sudo dpkg-reconfigure tzdata Asia 樹莓派由於沒有電池, 斷電後無法保存時間, 默認通過 NTP 服務獲取時間, 如果時間不準確, 可以 sudo ntpd -s –d 來校準 也可以 sudo date --s=&quot;2018-10-19 14:54:00&quot; 來設置時間 ","link":"https://IsumiAlice.github.io/post/gWUxHc_Er/"},{"title":"隨機性和亂數","content":"RANDOM.ORG是一個真正的亂數服務，它通過大氣雜訊生成隨機性。 亂數可用於各種目的，例如生成資料加密金鑰、類比和建模複雜現象以及從較大的資料集中選擇隨機樣本。它們也在美學上使用，例如在文學和音樂中，當然也流行於遊戲和賭博。在討論單個數位時，亂數是從一組可能的值中抽取的，每個值都同樣可能，即均勻分佈。在討論亂數序列時，繪製的每個數位在統計上必須獨立于其他數位。 隨著電腦的出現，程式師認識到需要一種將隨機性引入電腦程式的方法。然而，儘管看起來令人驚訝，但讓電腦偶然做某事是很困難的。電腦盲目地遵循其指令，因此是完全可預測的。（以這種方式不遵循其說明的電腦將損壞。使用電腦生成亂數有兩種主要方法：偽亂數產生器(PRNG)和真亂數產生器(TRNG)。這些方法具有完全不同的特點，每種方法都有其優缺點。 偽亂數產生器 正如&quot;偽&quot;一詞所暗示的，偽亂數不是您所期望的亂數字，至少如果你習慣于擲骰子或彩票的話。從本質上講，PRNG 是使用數學公式或只是預先計算表來生成亂數字序列的演算法。PRNG的一個很好的例子是線性同餘。大量的研究已經進入偽亂數理論，而現代的生成偽亂數的演算法是如此之好，以至於數位看起來與它們真正的隨機一樣。 如果將電腦生成的亂數與模具捲進行比較，則 PRNG 和 TRNG 之間的基本區別很容易理解。由於 PRNG 使用數學公式或預先計算的清單生成亂數，因此使用一個對應于多次滾動模具並寫下結果的人。每當您要求一個模具卷，你得到清單中的下一個。實際上，這些數位看起來是隨機的，但它們確實是預先確定的。TRNG 的工作方式是讓電腦實際滾動模具，或者更常見的是，使用一些比模具更容易連接到電腦的物理現象。 PRNG是有效的，這意味著它們可以在短時間內生成多個數位，並且是確定的，這意味著如果序列中的起點已知，則可以在以後複製給定的數位序列。如果應用程式需要許多數位，效率是一個不錯的特徵，如果您需要在稍後階段再次重播相同的數位序列，則確定性非常方便。PRNG 通常也是週期性的，這意味著序列最終將重複自身。雖然週期性幾乎不是一個理想的特徵，但現代 PRNG 的週期很長，可以忽略大多數實際用途。 這些特性使 PRNG 適用于需要多個數位且易於重重播放相同序列的應用。此類應用程式的熱門示例是模擬和建模應用程式。PRNG 不適合那些數位確實不可預知的應用程式，例如資料加密和賭博。 需要注意的是，即使存在良好的 PRNG 演算法，它們並不總是被使用，並且很容易得到令人討厭的意外。以流行的網路程式設計語言PHP為例。如果你使用PHP的GNU/Linux，你很可能完全滿意你的亂數。但是，如果您將 PHP 用於 Microsoft Windows，您可能會發現，您的亂數並不完全達到零標準，如 2008年的視覺化分析所示。另一個例子可追溯到2002年，當時一位研究人員報告說，MacOS上的PRNG不足以科學類比病毒感染。底線是，即使 PRNG 能夠滿足應用程式的需求，您仍需要小心使用哪個。 真正的亂數產生器 與 PRNG 相比，TRNG 從物理現象中提取隨機性並將其引入電腦。你可以想像這是連接到電腦的模具，但通常人們使用的物理現象比模具更容易連接到電腦。物理現象可能非常簡單，例如某人的滑鼠移動或按鍵之間的時間變化很小。然而，在實踐中，你必須小心你選擇的來源。例如，以這種方式使用擊鍵可能比較棘手，因為擊鍵通常由電腦的作業系統緩衝，這意味著在將多個擊鍵發送到等待擊鍵的程式之前，會收集多個按鍵。對於一個等待擊鍵的程式，它看起來好像鍵幾乎同步選取，而且可能沒有什麼隨機性。 但是，還有許多其他方法可以獲取電腦的真正隨機性。一個真正好的物理現象是一個放射源。放射源衰變的時間點是完全不可預測的，它們很容易被檢測到並輸入電腦，從而避免了作業系統中的任何緩衝機制。瑞士 Fourmilab 的HotBits 服務是使用此技術的亂數產生器的一個極好示例。另一個合適的物理現象是大氣雜訊，這是很容易拿起一個正常的無線電。這是RANDOM.ORG使用的方法。您也可以使用辦公室或實驗室的背景雜音，但您必須注意模式。電腦中的風扇可能會導致背景雜音，並且由於風扇是旋轉設備，因此其產生的雜訊很可能不會像大氣雜訊那樣隨機。 雷雨產生大氣噪音 只要你小心，可能性是無窮無盡的。毫無疑問，視覺上最酷的方法是拉瓦蘭發電機，它由矽圖形構建，並使用熔岩燈的快照來生成真正的亂數。不幸的是，拉瓦蘭不再運作，但它的發明者之一正在LavaRnd網站上（沒有熔岩燈）進行這項工作。另一種方法是JAVA熵Pool，它收集來自各種來源的隨機位，包括HotBits和RANDOM.ORG，但也從熵Pool自己的Web伺服器收到的網頁點擊。 無論使用哪種物理現象，生成真實亂數的過程都涉及識別資料中很少、不可預測的變化。例如，HotBits在放射性衰變發生之間的延遲變化很小，而RANDOM.ORG在大氣雜訊振幅上使用的變化很小。 TRNG 的特性與 PRNG 有很大不同。首先，與 PRNG 相比，TRN 通常效率很低，生成數位的時間要長得多。它們也是非確定性的，這意味著一個給定的數位序列不能被覆制，儘管同樣的序列當然會偶然出現幾次。TRNG 沒有期限。 量子事件還是混沌系統？ TRNG的構建者有時討論的一個特徵是所使用的物理現象是量子現象還是混沌行為現象。對於量子現象是否更好，存在著一些分歧，奇怪的是，這一切都歸結于我們對宇宙運作方式的信念。關鍵問題是宇宙是否是確定性的，也就是說，自大爆炸以來發生的一切是否基本上是預先確定的。決定論是一個困難的課題，它一直是許多哲學探究的主題，而這個問題遠沒有你想像的那麼清晰。我會嘗試在這裡解釋，但也要指出，Wiki 有一個簡明的敘述的辯論。 量子力學是理論物理學的一個分支，在原子和亞原子水準上用數學來描述宇宙。基於量子物理的亂數產生器使用亞原子粒子在某些情況下似乎隨機現象這一事實。似乎我們所知沒有任何原因導致這些事件，因此，許多人認為這些事件是無確定性的。 相比之下，混沌系統是指初始條件的微小變化可能導致系統整體行為發生巨大變化的系統。天氣系統就是一個很好的例子，你可能聽說過蝴蝶效應，這是一個思想實驗，一隻蝴蝶在巴西拍打翅膀，能夠微妙但批判地影響風，足以在德克薩斯州引發龍捲風。 量子變化亂數產生器的支援者認為量子物理學本質上是非確定性的，而由物理控制的系統本質上是確定性的。我個人尚未決定我的立場，在決定論-非決定論尺度上的立場，但為了爭論，我將戴上我最震懾的帽子，用RANDOM.ORG作為例子。你可能會爭辯說，大氣雜訊作為RANDOM.ORG數位的來源可以被看作是一個混亂但確定性的系統。因此，如果您對引起大氣噪音（例如雷暴）的過程有足夠的瞭解，則可以預測RANDOM.ORG產生的數量。 然而，要做到這一點，你可能需要瞭解地球天氣系統中每個分子的位置和速度。這當然不可行，而天氣預報的不准確是一個很好的例子，它很難對天氣系統的行為作出粗略的估計。因此，從RANDOM.ORG預測亂數是不切實際的，即使是對一個威懾者來說也是如此。對於基於熔岩燈的亂數發生器，也可以採用類似情況（在不同比例上）。 現在，你可能會認為，既然關於混沌現象是否適合產生隨機性存在爭議，那麼為什麼不堅持量子物理學呢？這似乎是安全的賭注。然而，量子發生器也不受批評。硬決定論者會聲稱亞原子粒子的行為並不是真正的隨機的，而是與大爆炸以來宇宙中其他一切事物完全一樣預先確定。我們認為這些特定粒子之所以隨機行為，僅僅是因為人類的測量無法解釋它們的行為。在這個觀點中，亞原子事件確實有先因，但我們只是不明白（尚未），因此事件對我們來說似乎是隨機的。對於一個難以阻止的人來說，量子物理學與大氣雜訊或熔岩燈一樣，完全適合亂數的生成。 這只是一個可能的論點，還有很多其他論點。綜合一下，我認為最有意義的隨機的定義是，這是無法預測的人類。隨機性是否源于不可預測的天氣系統、熔岩燈還是亞原子粒子事件，這在很大程度上是學術性的。雖然量子亂數產生器當然可以生成真正的亂數，但在我看來，它們對於所有意圖和目的都等同于基於複雜動態系統的方法。 ","link":"https://IsumiAlice.github.io/post/miVFuHvM6/"},{"title":"Steam 藝術作品展示欄設定","content":"分割個人資料背景 https://steam.design/ 瀏覽器中上傳藝術作品 選擇圖片 - F12 - Console var num= document.getElementsByName(&quot;image_width&quot;)[0].value; document.getElementsByName(&quot;image_height&quot;)[0].value = num-(num-1); document.getElementsByName(&quot;image_width&quot;)[0].value= num*100; 然後上傳圖片 上傳到熒幕截圖展櫃 document.getElementsByName(&quot;file_type&quot;)[0].value= 5; var num= document.getElementsByName(&quot;image_width&quot;)[0].value; document.getElementsByName(&quot;image_height&quot;)[0].value = num-(num-1); document.getElementsByName(&quot;image_width&quot;)[0].value= num*100; ","link":"https://IsumiAlice.github.io/post/steam-yi-shu-zuo-pin-zhan-shi-lan-she-ding/"},{"title":"「四疊半神話大系」讀書筆記","content":"2019-04-12 我是無人不知、無人不曉、惡名昭彰的戀愛絆腳石。我宛如一身死神裝扮的黑色丘比特，揮舞板斧而不是射出愛神的箭，東砍西砍到處砍斷像紅外線感應器般密布的命運紅線。據說我的所作所為，令年輕男女流下了六大洗臉盆的悲傷淚水。 2019-04-12 如果走夜路遇見他，十個人中有八個會誤以為他是妖怪，而其余兩人則是妖怪。 2019-04-12 雖說好聚好散，但我們卻使出吃奶的力氣，把原本猶如一池春水的人際關系，攪得猶如黃河般渾濁不堪。 2019-04-12 我心想，難不成他是我十年前分離的哥哥?但我沒有和哥哥生離，再說，我是第一次聽到自己有哥哥。 2019-04-12 常言道，光陰似箭，但像這樣季節不斷更疊，卻令人非常惱火。我不曉得打從盤古開天至今，過了多久的歲月，但從目前的情形來看，橫豎沒過多久。人在那麼短暫的時間內如此大量繁殖，令我十分驚訝。而且眾人每天費盡心思地汲汲營營。人這種生物實在很勤奮。了不起!所以說我覺得人不可愛，是騙人的。可是就算再可愛，我也沒有閑工夫憐憫那麼多人。 2019-04-12 我為了轉換心情而試圖用功念書。然而，面對教科書時，我漸漸覺得自己正在不顧形象地追回虛度的這兩年來，落後別人的部分。自己那種小家子氣的身影，違反我的美學原則自不待言。因此，念書被迫中斷。我奉即使綠燈閃爍也絕不跑著過馬路為信條。換句話說，我是個紳士。 2019-04-12 你要在意世人的目光，扭曲自己的信念嗎? 2019-04-13 明明對岸的迎新聯歡會氣氛越來越和睦，為什麼我卻得和這種一臉衰樣，長得像大正時代放高利貸的男人靠在一起呢?!我做錯了什麼?難道錯在我嗎?我心想，至少來個更誌同道合的人吧，如果是黑發美女更好。 2019-04-13 如果東邊有個墜入情網的少女，我就說：“放棄那種變態!”如果西邊有個癩蛤蟆想吃天鵝肉的男人，我就說：“別白費工夫!”如果南邊炸開愛情的火花，我馬上就去潑冷水，並且經常在北邊鼓吹戀愛無用論。 2019-04-13 老婦人擡起我的雙手，頻頻點頭，凝眸註視。 “嗯。你非常認真，而且才華洋溢。” 不用說，老婦人的慧眼馬上就令我佩服得五體投地。如同“真人不露相，露相非真人”這句俗語所說，因為我小心謹慎地隱瞞，以免被任何人察覺，所以這幾年來連我都已經不曉得自己的判斷能力和才華跑哪去了，但她竟然見面才不到五分鐘就看出來了，果然不是普通人。 2019-04-13 我積極地接受自己出生在無法過充實學生生活的星球這個事實。盡情享受浪費生命的學生生活。所以你沒理由對我說三道四。 2019-04-13 每天浪費生命，不是很快樂嗎? 2019-04-13 我討厭能夠理解我這種人的女人。最好是更柔若無骨、如夢似幻、胸大無腦的黑發美女。 2019-04-13 曾幾何時，我不在家的時候，水從二樓漏下來。我回家一看，滴下來的水不分猥褻不猥褻，把貴重書籍全都泡爛了。受害程度不止如此，計算機裏的貴重數據不分猥褻不猥褻，全都化為電子的碎藻。這件事使我的學業荒廢雪上加霜自不待言。 2019-04-13 沒有比有情人終成眷屬的愛情更不值一提的了。 2019-04-13 我不是會那麼輕易肯定過去的錯誤的單純男人。確實，我也曾幻想被偉大的愛情緊緊擁抱，但如果是嬌艷欲滴的少女也就罷了，誰會想要抱緊年過二十的邋遢男子呢?我被那種無法平息的憤怒所驅使，斷然拒絕拯救過去的自己。 2019-04-13 就像壽命長的動物身上會有一股不尋常的氣息，他身上也有一種類似仙人的氣質。 2019-04-13 因為他討厭蔬菜，老吃快餐食品，所以看臉色像是來自月球背面的人，非常觸目驚心。如果走夜路遇見他，十個人中有八個會誤以為他是妖怪，而其余兩人則是妖怪。他鞭打弱者、諂媚強者；任性妄為、傲慢無禮、怠惰成性，是上天派來的邪神，完全不念書，沒有半點自尊，能以他人的不幸為配菜吃三碗飯，幾乎一無是處。假如沒有遇見他，我的靈魂八成會更加潔凈。 2019-04-13 然而，今晚要現身在這裏的是小津。擁有汙穢Y染色體的黑心妖怪。 2019-04-14 他面露猥褻的笑容，不知道在暗爽什麼，八成是受到了來自Y染色體的不要臉想像所惑。 2019-04-14 在對大學生而言仍是晚上也不為過的早上七點，我被擾人清夢的敲門聲吵醒。 2019-04-14 閣下沒問題的。你至今的兩年很努力。不要說接下來的兩年，接下來的三年、四年也一定能夠出色地白白糟蹋掉。我向你保證。 2019-04-14 我們大部分的煩惱，是來自於夢想另一種有可能的人生。把希望寄托於自己的可能性這種不能指望的東西，正是萬惡的根源。你必須認同無法變成其他人的自己。你不可能能夠享受所謂的瑰麗學生生活。我向你保證，所以要沈著以對! 2019-04-14 俗話說“三歲看大”，而我已經二十有一，再過不久，就誕生在這世上將近四分之一個世紀了，事到如今，一個年輕人就算試圖改變自己的人格，做些無謂的努力，又能怎樣呢?若是勉強扭曲已經變得硬邦邦、屹立在半空中的人格，充其量就是喀嚓一聲折斷而已。 2019-04-15 我沒有迷戀女性內衣褲的嗜好，盡管如此，如果是女性的內衣褲在投幣式洗衣店遭竊，那還在我的理解範圍之內。但是，偷像我這種苦守節操兩年的高貴男子染滿體液的灰色內褲，有何樂趣可言呢?豈不是反而只會背負揮之不去的悲傷嗎? 2019-04-15 我誤入的社團“暖暖”，如同那個蠢到家的名字所示，就像春霞繚繞的天空中的浮雲般暖烘烘的。學長學姐和學弟學妹謙恭有禮地稱呼彼此，社團內完全不論輩分，不分學長學姐或學弟學妹，沒有憎恨和悲傷，就像是互投白球似的，持續一來一往地分享彼此的愛，大家一起愉快地互相扶持，是一個像把砂糖和牛奶加入維尼熊的蜂蜜中，以溫水稀釋的社團。 2019-04-16 說到大學生就是骯臟。說到骯臟就想到香菇。我心想，大概能吃長在壁櫥角落的香菇吧。 2019-04-16 如果隨時要把自己身體多余的部分變成糧食存活下去的話，大概會變成一場非常壯烈的存活戰，但我是個身體沒有半點贅肉，節省地球資源的人，所以多余的部分頂多只有耳垂。不是我在老王賣瓜，我就像烤麻雀似的全身只有一把骨頭，終究是個不能吃的男人。“那家夥是吃自己的耳垂存活下來的唷!”與其被人在背後這樣指指點點，我寧可選擇光榮地餓肚子。 ","link":"https://IsumiAlice.github.io/post/si-die-ban-shen-hua-da-xi-du-shu-bi-ji/"},{"title":"Python Cheatsheet","content":"https://github.com/gto76/python-cheatsheet Contents 1. Collections: List, Dictionary, Set, Tuple, Range, Enumerate, Iterator, Generator. 2. Types: Type, String, Regular_Exp, Format, Numbers, Combinatorics, Datetime. 3. Syntax: Args, Inline, Closure, Decorator, Class, Duck_Type, Enum, Exception. 4. System: Exit, Print, Input, Command_Line_Arguments, Open, Path, OS_Commands. 5. Data: JSON, Pickle, CSV, SQLite, Bytes, Struct, Array, Memory_View, Deque. 6. Advanced: Threading, Operator, Introspection, Metaprograming, Eval, Coroutines. 7. Libraries: Progress_Bar, Plot, Table, Curses, Logging, Scraping, Web, Profile, NumPy, Image, Audio, Pygame. Main if __name__ == '__main__': # Runs main() if file wasn't imported. main() List &lt;list&gt; = &lt;list&gt;[from_inclusive : to_exclusive : ±step_size] &lt;list&gt;.append(&lt;el&gt;) # Or: &lt;list&gt; += [&lt;el&gt;] &lt;list&gt;.extend(&lt;collection&gt;) # Or: &lt;list&gt; += &lt;collection&gt; &lt;list&gt;.sort() &lt;list&gt;.reverse() &lt;list&gt; = sorted(&lt;collection&gt;) &lt;iter&gt; = reversed(&lt;list&gt;) sum_of_elements = sum(&lt;collection&gt;) elementwise_sum = [sum(pair) for pair in zip(list_a, list_b)] sorted_by_second = sorted(&lt;collection&gt;, key=lambda el: el[1]) sorted_by_both = sorted(&lt;collection&gt;, key=lambda el: (el[1], el[0])) flatter_list = list(itertools.chain.from_iterable(&lt;list&gt;)) product_of_elems = functools.reduce(lambda out, el: out * el, &lt;collection&gt;) list_of_chars = list(&lt;str&gt;) Module operator provides functions itemgetter() and mul() that offer the same functionality as lambda expressions above. &lt;int&gt; = &lt;list&gt;.count(&lt;el&gt;) # Returns number of occurrences. Also works on strings. index = &lt;list&gt;.index(&lt;el&gt;) # Returns index of first occurrence or raises ValueError. &lt;list&gt;.insert(index, &lt;el&gt;) # Inserts item at index and moves the rest to the right. &lt;el&gt; = &lt;list&gt;.pop([index]) # Removes and returns item at index or from the end. &lt;list&gt;.remove(&lt;el&gt;) # Removes first occurrence of item or raises ValueError. &lt;list&gt;.clear() # Removes all items. Also works on dictionary and set. Dictionary &lt;view&gt; = &lt;dict&gt;.keys() # Coll. of keys that reflects changes. &lt;view&gt; = &lt;dict&gt;.values() # Coll. of values that reflects changes. &lt;view&gt; = &lt;dict&gt;.items() # Coll. of key-value tuples that reflects chgs. value = &lt;dict&gt;.get(key, default=None) # Returns default if key is missing. value = &lt;dict&gt;.setdefault(key, default=None) # Returns and writes default if key is missing. &lt;dict&gt; = collections.defaultdict(&lt;type&gt;) # Creates a dict with default value of type. &lt;dict&gt; = collections.defaultdict(lambda: 1) # Creates a dict with default value 1. &lt;dict&gt; = dict(&lt;collection&gt;) # Creates a dict from coll. of key-value pairs. &lt;dict&gt; = dict(zip(keys, values)) # Creates a dict from two collections. &lt;dict&gt; = dict.fromkeys(keys [, value]) # Creates a dict from collection of keys. &lt;dict&gt;.update(&lt;dict&gt;) # Adds items. Replaces ones with matching keys. value = &lt;dict&gt;.pop(key) # Removes item or raises KeyError. {k for k, v in &lt;dict&gt;.items() if v == value} # Returns set of keys that point to the value. {k: v for k, v in &lt;dict&gt;.items() if k in keys} # Returns a dictionary, filtered by keys. Counter &gt;&gt;&gt; from collections import Counter &gt;&gt;&gt; colors = ['blue', 'blue', 'blue', 'red', 'red'] &gt;&gt;&gt; counter = Counter(colors) &gt;&gt;&gt; counter['yellow'] += 1 Counter({'blue': 3, 'red': 2, 'yellow': 1}) &gt;&gt;&gt; counter.most_common()[0] ('blue', 3) Set &lt;set&gt; = set() &lt;set&gt;.add(&lt;el&gt;) # Or: &lt;set&gt; |= {&lt;el&gt;} &lt;set&gt;.update(&lt;collection&gt;) # Or: &lt;set&gt; |= &lt;set&gt; &lt;set&gt; = &lt;set&gt;.union(&lt;coll.&gt;) # Or: &lt;set&gt; | &lt;set&gt; &lt;set&gt; = &lt;set&gt;.intersection(&lt;coll.&gt;) # Or: &lt;set&gt; &amp; &lt;set&gt; &lt;set&gt; = &lt;set&gt;.difference(&lt;coll.&gt;) # Or: &lt;set&gt; - &lt;set&gt; &lt;set&gt; = &lt;set&gt;.symmetric_difference(&lt;coll.&gt;) # Or: &lt;set&gt; ^ &lt;set&gt; &lt;bool&gt; = &lt;set&gt;.issubset(&lt;coll.&gt;) # Or: &lt;set&gt; &lt;= &lt;set&gt; &lt;bool&gt; = &lt;set&gt;.issuperset(&lt;coll.&gt;) # Or: &lt;set&gt; &gt;= &lt;set&gt; &lt;el&gt; = &lt;set&gt;.pop() # Raises KeyError if empty. &lt;set&gt;.remove(&lt;el&gt;) # Raises KeyError if missing. &lt;set&gt;.discard(&lt;el&gt;) # Doesn't raise an error. Frozen Set Is immutable and hashable. That means it can be used as a key in a dictionary or as an element in a set. &lt;frozenset&gt; = frozenset(&lt;collection&gt;) Tuple Tuple is an immutable and hashable list. &lt;tuple&gt; = () &lt;tuple&gt; = (&lt;el&gt;, ) &lt;tuple&gt; = (&lt;el_1&gt;, &lt;el_2&gt; [, ...]) Named Tuple Tuple's subclass with named elements. &gt;&gt;&gt; from collections import namedtuple &gt;&gt;&gt; Point = namedtuple('Point', 'x y') &gt;&gt;&gt; p = Point(1, y=2) Point(x=1, y=2) &gt;&gt;&gt; p[0] 1 &gt;&gt;&gt; p.x 1 &gt;&gt;&gt; getattr(p, 'y') 2 &gt;&gt;&gt; p._fields # Or: Point._fields ('x', 'y') Range &lt;range&gt; = range(to_exclusive) &lt;range&gt; = range(from_inclusive, to_exclusive) &lt;range&gt; = range(from_inclusive, to_exclusive, ±step_size) from_inclusive = &lt;range&gt;.start to_exclusive = &lt;range&gt;.stop Enumerate for i, el in enumerate(&lt;collection&gt; [, i_start]): ... Iterator &lt;iter&gt; = iter(&lt;collection&gt;) # `iter(&lt;iter&gt;)` returns unmodified iterator. &lt;iter&gt; = iter(&lt;function&gt;, to_exclusive) # A sequence of return values until 'to_exclusive'. &lt;el&gt; = next(&lt;iter&gt; [, default]) # Raises StopIteration or returns 'default' on end. &lt;list&gt; = list(&lt;iter&gt;) # Returns a list of iterator's remaining elements. Itertools from itertools import count, repeat, cycle, chain, islice &lt;iter&gt; = count(start=0, step=1) # Returns incremented value endlessly. &lt;iter&gt; = repeat(&lt;el&gt; [, times]) # Returns element endlessly or 'times' times. &lt;iter&gt; = cycle(&lt;collection&gt;) # Repeats the sequence endlessly. &lt;iter&gt; = chain(&lt;coll_1&gt;, &lt;coll_2&gt; [, ...]) # Empties collections in order. &lt;iter&gt; = chain.from_iterable(&lt;collection&gt;) # Empties collections inside a collection in order. &lt;iter&gt; = islice(&lt;collection&gt;, to_exclusive) &lt;iter&gt; = islice(&lt;collection&gt;, from_inclusive, to_exclusive [, +step_size]) Generator Any function that contains a yield statement returns a generator. Generators and iterators are interchangeable. def count(start, step): while True: yield start start += step &gt;&gt;&gt; counter = count(10, 2) &gt;&gt;&gt; next(counter), next(counter), next(counter) (10, 12, 14) Type Everything is an object. Every object has a type. Type and class are synonymous. &lt;type&gt; = type(&lt;el&gt;) # Or: &lt;el&gt;.__class__ &lt;bool&gt; = isinstance(&lt;el&gt;, &lt;type&gt;) # Or: issubclass(type(&lt;el&gt;), &lt;type&gt;) &gt;&gt;&gt; type('a'), 'a'.__class__, str (&lt;class 'str'&gt;, &lt;class 'str'&gt;, &lt;class 'str'&gt;) Some types do not have built-in names, so they must be imported: from types import FunctionType, MethodType, LambdaType, GeneratorType ABC An abstract base class introduces virtual subclasses that don’t inherit from it, but are still recognized by isinstance() and issubclass(). &gt;&gt;&gt; from collections.abc import Sequence, Collection, Iterable &gt;&gt;&gt; isinstance([1, 2, 3], Iterable) True +------------------+------------+------------+------------+ | | Sequence | Collection | Iterable | +------------------+------------+------------+------------+ | list, range, str | yes | yes | yes | | dict, set | | yes | yes | | iter | | | yes | +------------------+------------+------------+------------+ &gt;&gt;&gt; from numbers import Integral, Rational, Real, Complex, Number &gt;&gt;&gt; isinstance(123, Number) True +--------------------+----------+----------+----------+----------+----------+ | | Integral | Rational | Real | Complex | Number | +--------------------+----------+----------+----------+----------+----------+ | int | yes | yes | yes | yes | yes | | fractions.Fraction | | yes | yes | yes | yes | | float | | | yes | yes | yes | | complex | | | | yes | yes | | decimal.Decimal | | | | | yes | +--------------------+----------+----------+----------+----------+----------+ String &lt;str&gt; = &lt;str&gt;.strip() # Strips all whitespace characters from both ends. &lt;str&gt; = &lt;str&gt;.strip('&lt;chars&gt;') # Strips all passed characters from both ends. &lt;list&gt; = &lt;str&gt;.split() # Splits on one or more whitespace characters. &lt;list&gt; = &lt;str&gt;.split(sep=None, maxsplit=-1) # Splits on 'sep' str at most 'maxsplit' times. &lt;list&gt; = &lt;str&gt;.splitlines(keepends=False) # Splits on \\n,\\r,\\r\\n. Keeps them if 'keepends'. &lt;str&gt; = &lt;str&gt;.join(&lt;coll_of_strings&gt;) # Joins elements using string as separator. &lt;bool&gt; = &lt;sub_str&gt; in &lt;str&gt; # Checks if string contains a substring. &lt;bool&gt; = &lt;str&gt;.startswith(&lt;sub_str&gt;) # Pass tuple of strings for multiple options. &lt;bool&gt; = &lt;str&gt;.endswith(&lt;sub_str&gt;) # Pass tuple of strings for multiple options. &lt;int&gt; = &lt;str&gt;.find(&lt;sub_str&gt;) # Returns start index of first match or -1. &lt;int&gt; = &lt;str&gt;.index(&lt;sub_str&gt;) # Same but raises ValueError if missing. &lt;str&gt; = &lt;str&gt;.replace(old, new [, count]) # Replaces 'old' with 'new' at most 'count' times. &lt;str&gt; = &lt;str&gt;.translate(&lt;table&gt;) # Use `str.maketrans(&lt;dict&gt;)` to generate table. &lt;str&gt; = chr(&lt;int&gt;) # Converts int to Unicode char. &lt;int&gt; = ord(&lt;str&gt;) # Converts Unicode char to int. Also: 'lstrip()', 'rstrip()'. Also: 'lower()', 'upper()', 'capitalize()' and 'title()'. Property Methods +---------------+----------+----------+----------+----------+----------+ | | [ !#$%…] | [a-zA-Z] | [¼½¾] | [²³¹] | [0-9] | +---------------+----------+----------+----------+----------+----------+ | isprintable() | yes | yes | yes | yes | yes | | isalnum() | | yes | yes | yes | yes | | isnumeric() | | | yes | yes | yes | | isdigit() | | | | yes | yes | | isdecimal() | | | | | yes | +---------------+----------+----------+----------+----------+----------+ Also: 'isspace()' checks for '[ \\t\\n\\r\\f\\v…]'. Regex import re &lt;str&gt; = re.sub(&lt;regex&gt;, new, text, count=0) # Substitutes all occurrences with 'new'. &lt;list&gt; = re.findall(&lt;regex&gt;, text) # Returns all occurrences as strings. &lt;list&gt; = re.split(&lt;regex&gt;, text, maxsplit=0) # Use brackets in regex to include the matches. &lt;Match&gt; = re.search(&lt;regex&gt;, text) # Searches for first occurrence of the pattern. &lt;Match&gt; = re.match(&lt;regex&gt;, text) # Searches only at the beginning of the text. &lt;iter&gt; = re.finditer(&lt;regex&gt;, text) # Returns all occurrences as match objects. Search() and match() return None if they can't find a match. Argument 'flags=re.IGNORECASE' can be used with all functions. Argument 'flags=re.MULTILINE' makes '^' and '$' match the start/end of each line. Argument 'flags=re.DOTALL' makes dot also accept the '\\n'. Use r'\\1' or '\\\\1' for backreference. Add '?' after an operator to make it non-greedy. Match Object &lt;str&gt; = &lt;Match&gt;.group() # Returns the whole match. Also group(0). &lt;str&gt; = &lt;Match&gt;.group(1) # Returns part in the first bracket. &lt;tuple&gt; = &lt;Match&gt;.groups() # Returns all bracketed parts. &lt;int&gt; = &lt;Match&gt;.start() # Returns start index of the match. &lt;int&gt; = &lt;Match&gt;.end() # Returns exclusive end index of the match. Special Sequences By default digits, alphanumerics and whitespaces from all alphabets are matched, unless 'flags=re.ASCII' argument is used. Use a capital letter for negation. '\\d' == '[0-9]' # Matches any digit. '\\w' == '[a-zA-Z0-9_]' # Matches any alphanumeric. '\\s' == '[ \\t\\n\\r\\f\\v]' # Matches any whitespace. Format &lt;str&gt; = f'{&lt;el_1&gt;}, {&lt;el_2&gt;}' &lt;str&gt; = '{}, {}'.format(&lt;el_1&gt;, &lt;el_2&gt;) Attributes &gt;&gt;&gt; from collections import namedtuple &gt;&gt;&gt; Person = namedtuple('Person', 'name height') &gt;&gt;&gt; person = Person('Jean-Luc', 187) &gt;&gt;&gt; f'{person.height}' '187' &gt;&gt;&gt; '{p.height}'.format(p=person) '187' General Options {&lt;el&gt;:&lt;10} # '&lt;el&gt; ' {&lt;el&gt;:^10} # ' &lt;el&gt; ' {&lt;el&gt;:&gt;10} # ' &lt;el&gt;' {&lt;el&gt;:.&lt;10} # '&lt;el&gt;......' {&lt;el&gt;:&lt;0} # '&lt;el&gt;' Strings '!r' calls object's repr() method, instead of str(), to get a string. {'abcde'!r:10} # &quot;'abcde' &quot; {'abcde':10.3} # 'abc ' {'abcde':.3} # 'abc' Numbers { 123456:10,} # ' 123,456' { 123456:10_} # ' 123_456' { 123456:+10} # ' +123456' {-123456:=10} # '- 123456' { 123456: } # ' 123456' {-123456: } # '-123456' Floats {1.23456:10.3} # ' 1.23' {1.23456:10.3f} # ' 1.235' {1.23456:10.3e} # ' 1.235e+00' {1.23456:10.3%} # ' 123.456%' Comparison of presentation types: +---------------+-----------------+-----------------+-----------------+-----------------+ | | {&lt;float&gt;} | {&lt;float&gt;:f} | {&lt;float&gt;:e} | {&lt;float&gt;:%} | +---------------+-----------------+-----------------+-----------------+-----------------+ | 0.000056789 | '5.6789e-05' | '0.000057' | '5.678900e-05' | '0.005679%' | | 0.00056789 | '0.00056789' | '0.000568' | '5.678900e-04' | '0.056789%' | | 0.0056789 | '0.0056789' | '0.005679' | '5.678900e-03' | '0.567890%' | | 0.056789 | '0.056789' | '0.056789' | '5.678900e-02' | '5.678900%' | | 0.56789 | '0.56789' | '0.567890' | '5.678900e-01' | '56.789000%' | | 5.6789 | '5.6789' | '5.678900' | '5.678900e+00' | '567.890000%' | | 56.789 | '56.789' | '56.789000' | '5.678900e+01' | '5678.900000%' | | 567.89 | '567.89' | '567.890000' | '5.678900e+02' | '56789.000000%' | +---------------+-----------------+-----------------+-----------------+-----------------+ +---------------+-----------------+-----------------+-----------------+-----------------+ | | {&lt;float&gt;:.2} | {&lt;float&gt;:.2f} | {&lt;float&gt;:.2e} | {&lt;float&gt;:.2%} | +---------------+-----------------+-----------------+-----------------+-----------------+ | 0.000056789 | '5.7e-05' | '0.00' | '5.68e-05' | '0.01%' | | 0.00056789 | '0.00057' | '0.00' | '5.68e-04' | '0.06%' | | 0.0056789 | '0.0057' | '0.01' | '5.68e-03' | '0.57%' | | 0.056789 | '0.057' | '0.06' | '5.68e-02' | '5.68%' | | 0.56789 | '0.57' | '0.57' | '5.68e-01' | '56.79%' | | 5.6789 | '5.7' | '5.68' | '5.68e+00' | '567.89%' | | 56.789 | '5.7e+01' | '56.79' | '5.68e+01' | '5678.90%' | | 567.89 | '5.7e+02' | '567.89' | '5.68e+02' | '56789.00%' | +---------------+-----------------+-----------------+-----------------+-----------------+ Ints {90:c} # 'Z' {90:b} # '1011010' {90:X} # '5A' Numbers Types &lt;int&gt; = int(&lt;float/str/bool&gt;) # Or: math.floor(&lt;float&gt;) &lt;float&gt; = float(&lt;int/str/bool&gt;) # Or: &lt;real&gt;e±&lt;int&gt; &lt;complex&gt; = complex(real=0, imag=0) # Or: &lt;real&gt; ± &lt;real&gt;j &lt;Fraction&gt; = fractions.Fraction(numerator=0, denominator=1) &lt;Decimal&gt; = decimal.Decimal(&lt;str/int/float&gt;) 'int(&lt;str&gt;)' and 'float(&lt;str&gt;)' raise ValueError on malformed strings. Decimal numbers can be represented exactly, unlike floats where '1.1 + 2.2 != 3.3'. Precision of decimal operations is set with: 'decimal.getcontext().prec = &lt;int&gt;'. Basic Functions &lt;num&gt; = pow(&lt;num&gt;, &lt;num&gt;) # Or: &lt;num&gt; ** &lt;num&gt; &lt;num&gt; = abs(&lt;num&gt;) # &lt;float&gt; = abs(&lt;complex&gt;) &lt;num&gt; = round(&lt;num&gt; [, ±ndigits]) # `round(126, -1) == 130` Math from math import e, pi, inf, nan from math import cos, acos, sin, asin, tan, atan, degrees, radians from math import log, log10, log2 Statistics from statistics import mean, median, variance, pvariance, pstdev Random from random import random, randint, choice, shuffle &lt;float&gt; = random() &lt;int&gt; = randint(from_inclusive, to_inclusive) &lt;el&gt; = choice(&lt;list&gt;) shuffle(&lt;list&gt;) Bin, Hex &lt;int&gt; = 0b&lt;bin&gt; # Or: 0x&lt;hex&gt; &lt;int&gt; = int('&lt;bin&gt;', 2) # Or: int('&lt;hex&gt;', 16) &lt;int&gt; = int('0b&lt;bin&gt;', 0) # Or: int('0x&lt;hex&gt;', 0) '0b&lt;bin&gt;' = bin(&lt;int&gt;) # Or: hex(&lt;int&gt;) Bitwise Operators &lt;int&gt; = &lt;int&gt; &amp; &lt;int&gt; # And &lt;int&gt; = &lt;int&gt; | &lt;int&gt; # Or &lt;int&gt; = &lt;int&gt; ^ &lt;int&gt; # Xor (0 if both bits equal) &lt;int&gt; = &lt;int&gt; &lt;&lt; n_bits # Shift left &lt;int&gt; = &lt;int&gt; &gt;&gt; n_bits # Shift right &lt;int&gt; = ~&lt;int&gt; # Compliment (flips bits) Combinatorics Every function returns an iterator. If you want to print the iterator, you need to pass it to the list() function first! from itertools import product, combinations, combinations_with_replacement, permutations &gt;&gt;&gt; product([0, 1], repeat=3) [(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)] &gt;&gt;&gt; product('ab', '12') [('a', '1'), ('a', '2'), ('b', '1'), ('b', '2')] &gt;&gt;&gt; combinations('abc', 2) [('a', 'b'), ('a', 'c'), ('b', 'c')] &gt;&gt;&gt; combinations_with_replacement('abc', 2) [('a', 'a'), ('a', 'b'), ('a', 'c'), ('b', 'b'), ('b', 'c'), ('c', 'c')] &gt;&gt;&gt; permutations('abc', 2) [('a', 'b'), ('a', 'c'), ('b', 'a'), ('b', 'c'), ('c', 'a'), ('c', 'b')] Datetime Module 'datetime' provides 'date' &lt;D&gt;, 'time' &lt;T&gt;, 'datetime' &lt;DT&gt; and 'timedelta' &lt;TD&gt; classes. All are immutable and hashable. Time and datetime objects can be 'aware' &lt;a&gt;, meaning they have defined timezone, or 'naive' &lt;n&gt;, meaning they don't. If object is naive, it is presumed to be in the system's timezone. from datetime import date, time, datetime, timedelta from dateutil.tz import UTC, tzlocal, gettz, resolve_imaginary Constructors &lt;D&gt; = date(year, month, day) &lt;T&gt; = time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, fold=0) &lt;DT&gt; = datetime(year, month, day, hour=0, minute=0, second=0, ...) &lt;TD&gt; = timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0) Use '&lt;D/DT&gt;.weekday()' to get the day of the week (Mon == 0). 'fold=1' means the second pass in case of time jumping back for one hour. '&lt;DTa&gt; = resolve_imaginary(&lt;DTa&gt;)' fixes DTs that fall into the missing hour. Now &lt;D/DTn&gt; = D/DT.today() # Current local date or naive datetime. &lt;DTn&gt; = DT.utcnow() # Naive datetime from current UTC time. &lt;DTa&gt; = DT.now(&lt;tzinfo&gt;) # Aware datetime from current tz time. To extract time use '&lt;DTn&gt;.time()', '&lt;DTa&gt;.time()' or '&lt;DTa&gt;.timetz()'. Timezone &lt;tzinfo&gt; = UTC # UTC timezone. London without DST. &lt;tzinfo&gt; = tzlocal() # Local timezone. Also gettz(). &lt;tzinfo&gt; = gettz('&lt;Cont.&gt;/&lt;City&gt;') # 'Continent/City_Name' timezone or None. &lt;DTa&gt; = &lt;DT&gt;.astimezone(&lt;tzinfo&gt;) # Datetime, converted to passed timezone. &lt;Ta/DTa&gt; = &lt;T/DT&gt;.replace(tzinfo=&lt;tzinfo&gt;) # Unconverted object with new timezone. Encode &lt;D/T/DT&gt; = D/T/DT.fromisoformat('&lt;iso&gt;') # Object from ISO string. Raises ValueError. &lt;DT&gt; = DT.strptime(&lt;str&gt;, '&lt;format&gt;') # Datetime from str, according to format. &lt;D/DTn&gt; = D/DT.fromordinal(&lt;int&gt;) # D/DTn from days since Christ, at midnight. &lt;DTn&gt; = DT.fromtimestamp(&lt;real&gt;) # Local time DTn from seconds since Epoch. &lt;DTa&gt; = DT.fromtimestamp(&lt;real&gt;, &lt;tz.&gt;) # Aware datetime from seconds since Epoch. ISO strings come in following forms: 'YYYY-MM-DD', 'HH:MM:SS.ffffff[±&lt;offset&gt;]', or both separated by an arbitrary character. Offset is formatted as: 'HH:MM'. Epoch on Unix systems is: '1970-01-01 00:00 UTC', '1970-01-01 01:00 CET', ... Decode &lt;str&gt; = &lt;D/T/DT&gt;.isoformat(sep='T') # Also timespec='auto/hours/minutes/seconds'. &lt;str&gt; = &lt;D/T/DT&gt;.strftime('&lt;format&gt;') # Custom string representation. &lt;int&gt; = &lt;D/DT&gt;.toordinal() # Days since Christ, ignoring time and tz. &lt;float&gt; = &lt;DTn&gt;.timestamp() # Seconds since Epoch, from DTn in local tz. &lt;float&gt; = &lt;DTa&gt;.timestamp() # Seconds since Epoch, from DTa. Format &gt;&gt;&gt; from datetime import datetime &gt;&gt;&gt; dt = datetime.strptime('2015-05-14 23:39:00.00 +0200', '%Y-%m-%d %H:%M:%S.%f %z') &gt;&gt;&gt; dt.strftime(&quot;%A, %dth of %B '%y, %I:%M%p %Z&quot;) &quot;Thursday, 14th of May '15, 11:39PM UTC+02:00&quot; When parsing, '%z' also accepts '±HH:MM'. For abbreviated weekday and month use '%a' and '%b'. Arithmetics &lt;D/DT&gt; = &lt;D/DT&gt; ± &lt;TD&gt; # Returned datetime can fall into missing hour. &lt;TD&gt; = &lt;D/DTn&gt; - &lt;D/DTn&gt; # Returns the difference, ignoring time jumps. &lt;TD&gt; = &lt;DTa&gt; - &lt;DTa&gt; # Ignores time jumps if they share tzinfo object. &lt;TD&gt; = &lt;DT_UTC&gt; - &lt;DT_UTC&gt; # Convert DTs to UTC to get the actual delta. Arguments Inside Function Call &lt;function&gt;(&lt;positional_args&gt;) # f(0, 0) &lt;function&gt;(&lt;keyword_args&gt;) # f(x=0, y=0) &lt;function&gt;(&lt;positional_args&gt;, &lt;keyword_args&gt;) # f(0, y=0) Inside Function Definition def f(&lt;nondefault_args&gt;): # def f(x, y): def f(&lt;default_args&gt;): # def f(x=0, y=0): def f(&lt;nondefault_args&gt;, &lt;default_args&gt;): # def f(x, y=0): Splat Operator Inside Function Call Splat expands a collection into positional arguments, while splatty-splat expands a dictionary into keyword arguments. args = (1, 2) kwargs = {'x': 3, 'y': 4, 'z': 5} func(*args, **kwargs) Is the same as: func(1, 2, x=3, y=4, z=5) Inside Function Definition Splat combines zero or more positional arguments into a tuple, while splatty-splat combines zero or more keyword arguments into a dictionary. def add(*a): return sum(a) &gt;&gt;&gt; add(1, 2, 3) 6 Legal argument combinations: def f(x, y, z): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) | f(1, 2, 3) def f(*, x, y, z): # f(x=1, y=2, z=3) def f(x, *, y, z): # f(x=1, y=2, z=3) | f(1, y=2, z=3) def f(x, y, *, z): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) def f(*args): # f(1, 2, 3) def f(x, *args): # f(1, 2, 3) def f(*args, z): # f(1, 2, z=3) def f(x, *args, z): # f(1, 2, z=3) def f(**kwargs): # f(x=1, y=2, z=3) def f(x, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) def f(*, x, **kwargs): # f(x=1, y=2, z=3) def f(*args, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) | f(1, 2, 3) def f(x, *args, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) | f(1, 2, 3) def f(*args, y, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) def f(x, *args, z, **kwargs): # f(x=1, y=2, z=3) | f(1, y=2, z=3) | f(1, 2, z=3) Other Uses &lt;list&gt; = [*&lt;collection&gt; [, ...]] &lt;set&gt; = {*&lt;collection&gt; [, ...]} &lt;tuple&gt; = (*&lt;collection&gt;, [...]) &lt;dict&gt; = {**&lt;dict&gt; [, ...]} head, *body, tail = &lt;collection&gt; Inline Lambda &lt;function&gt; = lambda: &lt;return_value&gt; &lt;function&gt; = lambda &lt;argument_1&gt;, &lt;argument_2&gt;: &lt;return_value&gt; Comprehension &lt;list&gt; = [i+1 for i in range(10)] # [1, 2, ..., 10] &lt;set&gt; = {i for i in range(10) if i &gt; 5} # {6, 7, 8, 9} &lt;iter&gt; = (i+5 for i in range(10)) # (5, 6, ..., 14) &lt;dict&gt; = {i: i*2 for i in range(10)} # {0: 0, 1: 2, ..., 9: 18} out = [i+j for i in range(10) for j in range(10)] Is the same as: out = [] for i in range(10): for j in range(10): out.append(i+j) Map, Filter, Reduce from functools import reduce &lt;iter&gt; = map(lambda x: x + 1, range(10)) # (1, 2, ..., 10) &lt;iter&gt; = filter(lambda x: x &gt; 5, range(10)) # (6, 7, 8, 9) &lt;obj&gt; = reduce(lambda out, x: out + x, range(10)) # 45 Any, All &lt;bool&gt; = any(&lt;collection&gt;) # False if empty. &lt;bool&gt; = all(el[1] for el in &lt;collection&gt;) # True if empty. If - Else &lt;obj&gt; = &lt;expression_if_true&gt; if &lt;condition&gt; else &lt;expression_if_false&gt; &gt;&gt;&gt; [a if a else 'zero' for a in (0, 1, 2, 3)] ['zero', 1, 2, 3] Namedtuple, Enum, Dataclass from collections import namedtuple Point = namedtuple('Point', 'x y') point = Point(0, 0) from enum import Enum Direction = Enum('Direction', 'n e s w') direction = Direction.n from dataclasses import make_dataclass Creature = make_dataclass('Creature', ['location', 'direction']) creature = Creature(Point(0, 0), Direction.n) Closure We have a closure in Python when: A nested function references a value of its enclosing function and then the enclosing function returns the nested function. def get_multiplier(a): def out(b): return a * b return out &gt;&gt;&gt; multiply_by_3 = get_multiplier(3) &gt;&gt;&gt; multiply_by_3(10) 30 If multiple nested functions within enclosing function reference the same value, that value gets shared. To dynamically access function's first free variable use '&lt;function&gt;.__closure__[0].cell_contents'. Partial from functools import partial &lt;function&gt; = partial(&lt;function&gt; [, &lt;arg_1&gt;, &lt;arg_2&gt;, ...]) &gt;&gt;&gt; import operator as op &gt;&gt;&gt; multiply_by_3 = partial(op.mul, 3) &gt;&gt;&gt; multiply_by_3(10) 30 Partial is also useful in cases when function needs to be passed as an argument, because it enables us to set its arguments beforehand. A few examples being: 'defaultdict(&lt;function&gt;)', 'iter(&lt;function&gt;, to_exclusive)' and dataclass's 'field(default_factory=&lt;function&gt;)'. Nonlocal If variable is being assigned to anywhere in the scope, it is regarded as a local variable, unless it is declared as a 'global' or a 'nonlocal'. def get_counter(): i = 0 def out(): nonlocal i i += 1 return i return out &gt;&gt;&gt; counter = get_counter() &gt;&gt;&gt; counter(), counter(), counter() (1, 2, 3) Decorator A decorator takes a function, adds some functionality and returns it. @decorator_name def function_that_gets_passed_to_decorator(): ... Debugger Example Decorator that prints function's name every time it gets called. from functools import wraps def debug(func): @wraps(func) def out(*args, **kwargs): print(func.__name__) return func(*args, **kwargs) return out @debug def add(x, y): return x + y Wraps is a helper decorator that copies the metadata of the passed function (func) to the function it is wrapping (out). Without it 'add.__name__' would return 'out'. LRU Cache Decorator that caches function's return values. All function's arguments must be hashable. from functools import lru_cache @lru_cache(maxsize=None) def fib(n): return n if n &lt; 2 else fib(n-2) + fib(n-1) CPython interpreter limits recursion depth to 1000 by default. To increase it use 'sys.setrecursionlimit(&lt;depth&gt;)'. Parametrized Decorator A decorator that accepts arguments and returns a normal decorator that accepts a function. from functools import wraps def debug(print_result=False): def decorator(func): @wraps(func) def out(*args, **kwargs): result = func(*args, **kwargs) print(func.__name__, result if print_result else '') return result return out return decorator @debug(print_result=True) def add(x, y): return x + y Class class &lt;name&gt;: def __init__(self, a): self.a = a def __repr__(self): class_name = self.__class__.__name__ return f'{class_name}({self.a!r})' def __str__(self): return str(self.a) @classmethod def get_class_name(cls): return cls.__name__ Return value of repr() should be unambiguous and of str() readable. If only repr() is defined, it will also be used for str(). Str() use cases: print(&lt;el&gt;) print(f'{&lt;el&gt;}') raise Exception(&lt;el&gt;) loguru.logger.debug(&lt;el&gt;) csv.writer(&lt;file&gt;).writerow([&lt;el&gt;]) Repr() use cases: print([&lt;el&gt;]) print(f'{&lt;el&gt;!r}') &gt;&gt;&gt; &lt;el&gt; loguru.logger.exception() Z = dataclasses.make_dataclass('Z', ['a']); print(Z(&lt;el&gt;)) Constructor Overloading class &lt;name&gt;: def __init__(self, a=None): self.a = a Inheritance class Person: def __init__(self, name, age): self.name = name self.age = age class Employee(Person): def __init__(self, name, age, staff_num): super().__init__(name, age) self.staff_num = staff_num Multiple Inheritance class A: pass class B: pass class C(A, B): pass MRO determines the order in which parent classes are traversed when searching for a method: &gt;&gt;&gt; C.mro() [&lt;class 'C'&gt;, &lt;class 'A'&gt;, &lt;class 'B'&gt;, &lt;class 'object'&gt;] Property Pythonic way of implementing getters and setters. class MyClass: @property def a(self): return self._a @a.setter def a(self, value): self._a = value &gt;&gt;&gt; el = MyClass() &gt;&gt;&gt; el.a = 123 &gt;&gt;&gt; el.a 123 Dataclass Decorator that automatically generates init(), repr() and eq() special methods. from dataclasses import dataclass, field @dataclass(order=False, frozen=False) class &lt;class_name&gt;: &lt;attr_name_1&gt;: &lt;type&gt; &lt;attr_name_2&gt;: &lt;type&gt; = &lt;default_value&gt; &lt;attr_name_3&gt;: list/dict/set = field(default_factory=list/dict/set) Objects can be made sortable with 'order=True' and/or immutable and hashable with 'frozen=True'. Function field() is needed because '&lt;attr_name&gt;: list = []' would make a list that is shared among all instances. Default_factory can be any callable. Inline: from dataclasses import make_dataclass &lt;class&gt; = make_dataclass('&lt;class_name&gt;', &lt;coll_of_attribute_names&gt;) &lt;class&gt; = make_dataclass('&lt;class_name&gt;', &lt;coll_of_tuples&gt;) &lt;tuple&gt; = ('&lt;attr_name&gt;', &lt;type&gt; [, &lt;default_value&gt;]) Slots Mechanism that restricts objects to attributes listed in 'slots' and significantly reduces their memory footprint. class MyClassWithSlots: __slots__ = ['a'] def __init__(self): self.a = 1 Copy from copy import copy, deepcopy &lt;object&gt; = copy(&lt;object&gt;) &lt;object&gt; = deepcopy(&lt;object&gt;) Duck Types A duck type is an implicit type that prescribes a set of special methods. Any object that has those methods defined is considered a member of that duck type. Comparable If eq() method is not overridden, it returns 'id(self) == id(other)', which is the same as 'self is other'. That means all objects compare not equal by default. Only the left side object has eq() method called, unless it returns NotImplemented, in which case the right object is consulted. class MyComparable: def __init__(self, a): self.a = a def __eq__(self, other): if isinstance(other, type(self)): return self.a == other.a return NotImplemented Hashable Hashable object needs both hash() and eq() methods and its hash value should never change. Hashable objects that compare equal must have the same hash value, meaning default hash() that returns 'id(self)' will not do. That is why Python automatically makes classes unhashable if you only implement eq(). class MyHashable: def __init__(self, a): self._a = a @property def a(self): return self._a def __eq__(self, other): if isinstance(other, type(self)): return self.a == other.a return NotImplemented def __hash__(self): return hash(self.a) Sortable With total_ordering decorator you only need to provide eq() and one of lt(), gt(), le() or ge() special methods. from functools import total_ordering @total_ordering class MySortable: def __init__(self, a): self.a = a def __eq__(self, other): if isinstance(other, type(self)): return self.a == other.a return NotImplemented def __lt__(self, other): if isinstance(other, type(self)): return self.a &lt; other.a return NotImplemented Iterator Any object that has methods next() and iter() is an iterator. Next() should return next item or raise StopIteration. Iter() should return 'self'. class Counter: def __init__(self): self.i = 0 def __next__(self): self.i += 1 return self.i def __iter__(self): return self &gt;&gt;&gt; counter = Counter() &gt;&gt;&gt; next(counter), next(counter), next(counter) (1, 2, 3) Python has many different iterator objects: Iterators returned by the iter() function, such as list_iterator and set_iterator. Objects returned by the itertools module, such as count, repeat and cycle. Generators returned by the generator functions and generator expressions. File objects returned by the open() function, etc. Callable All functions and classes have a call() method, hence are callable. When this cheatsheet uses '&lt;function&gt;' as an argument, it actually means '&lt;callable&gt;'. class Counter: def __init__(self): self.i = 0 def __call__(self): self.i += 1 return self.i &gt;&gt;&gt; counter = Counter() &gt;&gt;&gt; counter(), counter(), counter() (1, 2, 3) Context Manager Enter() should lock the resources and optionally return an object. Exit() should release the resources. Any exception that happens inside the with block is passed to the exit() method. If it wishes to suppress the exception it must return a true value. class MyOpen(): def __init__(self, filename): self.filename = filename def __enter__(self): self.file = open(self.filename) return self.file def __exit__(self, exc_type, exception, traceback): self.file.close() &gt;&gt;&gt; with open('test.txt', 'w') as file: ... file.write('Hello World!') &gt;&gt;&gt; with MyOpen('test.txt') as file: ... print(file.read()) Hello World! Iterable Duck Types Iterable Only required method is iter(). It should return an iterator of object's items. Contains() automatically works on any object that has iter() defined. class MyIterable: def __init__(self, a): self.a = a def __iter__(self): return iter(self.a) def __contains__(self, el): return el in self.a &gt;&gt;&gt; obj = MyIterable([1, 2, 3]) &gt;&gt;&gt; [el for el in obj] [1, 2, 3] &gt;&gt;&gt; 1 in obj True Collection Only required methods are iter() and len(). This cheatsheet actually means '&lt;iterable&gt;' when it uses '&lt;collection&gt;'. I chose not to use the name 'iterable' because it sounds scarier and more vague than 'collection'. class MyCollection: def __init__(self, a): self.a = a def __iter__(self): return iter(self.a) def __contains__(self, el): return el in self.a def __len__(self): return len(self.a) Sequence Only required methods are len() and getitem(). Getitem() should return an item at index or raise IndexError. Iter() and contains() automatically work on any object that has getitem() defined. Reversed() automatically works on any object that has getitem() and len() defined. class MySequence: def __init__(self, a): self.a = a def __iter__(self): return iter(self.a) def __contains__(self, el): return el in self.a def __len__(self): return len(self.a) def __getitem__(self, i): return self.a[i] def __reversed__(self): return reversed(self.a) Collections.abc.Sequence It's a richer interface than the basic sequence. Extending it generates iter(), contains(), reversed(), index() and count(). Unlike 'abc.Iterable' and 'abc.Collection', it is not a duck type. That is why 'issubclass(MySequence, abc.Sequence)' would return False even if MySequence had all the methods defined. from collections import abc class MyAbcSequence(abc.Sequence): def __init__(self, a): self.a = a def __len__(self): return len(self.a) def __getitem__(self, i): return self.a[i] Table of required and automatically available special methods: +------------+------------+------------+------------+--------------+ | | Iterable | Collection | Sequence | abc.Sequence | +------------+------------+------------+------------+--------------+ | iter() | REQ | REQ | Yes | Yes | | contains() | Yes | Yes | Yes | Yes | | len() | | REQ | REQ | REQ | | getitem() | | | REQ | REQ | | reversed() | | | Yes | Yes | | index() | | | | Yes | | count() | | | | Yes | +------------+------------+------------+------------+--------------+ Other ABCs that generate missing methods are: MutableSequence, Set, MutableSet, Mapping and MutableMapping. Names of their required methods are stored in '&lt;abc&gt;.__abstractmethods__'. Enum from enum import Enum, auto class &lt;enum_name&gt;(Enum): &lt;member_name_1&gt; = &lt;value_1&gt; &lt;member_name_2&gt; = &lt;value_2_a&gt;, &lt;value_2_b&gt; &lt;member_name_3&gt; = auto() If there are no numeric values before auto(), it returns 1. Otherwise it returns an increment of the last numeric value. &lt;member&gt; = &lt;enum&gt;.&lt;member_name&gt; # Returns a member. &lt;member&gt; = &lt;enum&gt;['&lt;member_name&gt;'] # Returns a member or raises KeyError. &lt;member&gt; = &lt;enum&gt;(&lt;value&gt;) # Returns a member or raises ValueError. &lt;str&gt; = &lt;member&gt;.name # Returns member's name. &lt;obj&gt; = &lt;member&gt;.value # Returns member's value. list_of_members = list(&lt;enum&gt;) member_names = [a.name for a in &lt;enum&gt;] member_values = [a.value for a in &lt;enum&gt;] random_member = random.choice(list(&lt;enum&gt;)) def get_next_member(member): members = list(member.__class__) index = (members.index(member) + 1) % len(members) return members[index] Inline Cutlery = Enum('Cutlery', 'fork knife spoon') Cutlery = Enum('Cutlery', ['fork', 'knife', 'spoon']) Cutlery = Enum('Cutlery', {'fork': 1, 'knife': 2, 'spoon': 3}) User-defined functions cannot be values, so they must be wrapped: from functools import partial LogicOp = Enum('LogicOp', {'AND': partial(lambda l, r: l and r), 'OR' : partial(lambda l, r: l or r)}) Another solution in this particular case is to use built-in functions and_() and or_() from the module operator. Exceptions Basic Example try: &lt;code&gt; except &lt;exception&gt;: &lt;code&gt; Complex Example try: &lt;code_1&gt; except &lt;exception_a&gt;: &lt;code_2_a&gt; except &lt;exception_b&gt;: &lt;code_2_b&gt; else: &lt;code_2_c&gt; finally: &lt;code_3&gt; Catching Exceptions except &lt;exception&gt;: except &lt;exception&gt; as &lt;name&gt;: except (&lt;exception&gt;, ...): except (&lt;exception&gt;, ...) as &lt;name&gt;: Also catches subclasses of the exception. Use 'traceback.print_exc()' to print the error message. Raising Exceptions raise &lt;exception&gt; raise &lt;exception&gt;() raise &lt;exception&gt;(&lt;el&gt; [, ...]) Re-raising caught exception: except &lt;exception&gt; as &lt;name&gt;: ... raise Exception Object arguments = &lt;name&gt;.args exc_type = &lt;name&gt;.__class__ filename = &lt;name&gt;.__traceback__.tb_frame.f_code.co_filename func_name = &lt;name&gt;.__traceback__.tb_frame.f_code.co_name line = linecache.getline(filename, &lt;name&gt;.__traceback__.tb_lineno) error_msg = traceback.format_exception(exc_type, &lt;name&gt;, &lt;name&gt;.__traceback__) Built-in Exceptions BaseException +-- SystemExit # Raised by the sys.exit() function. +-- KeyboardInterrupt # Raised when the user hits the interrupt key (ctrl-c). +-- Exception # User-defined exceptions should be derived from this class. +-- ArithmeticError # Base class for arithmetic errors. | +-- ZeroDivisionError # Raised when dividing by zero. +-- AttributeError # Raised when an attribute is missing. +-- EOFError # Raised by input() when it hits end-of-file condition. +-- LookupError # Raised when a look-up on a collection fails. | +-- IndexError # Raised when a sequence index is out of range. | +-- KeyError # Raised when a dictionary key or set element is not found. +-- NameError # Raised when a variable name is not found. +-- OSError # Failures such as “file not found” or “disk full”. | +-- FileNotFoundError # When a file or directory is requested but doesn't exist. +-- RuntimeError # Raised by errors that don't fall in other categories. | +-- RecursionError # Raised when the maximum recursion depth is exceeded. +-- StopIteration # Raised by next() when run on an empty iterator. +-- TypeError # Raised when an argument is of wrong type. +-- ValueError # When an argument is of right type but inappropriate value. +-- UnicodeError # Raised when encoding/decoding strings to/from bytes fails. Collections and their exceptions: +-----------+------------+------------+------------+ | | list | dict | set | +-----------+------------+------------+------------+ | getitem() | IndexError | KeyError | | | pop() | IndexError | KeyError | KeyError | | remove() | ValueError | | KeyError | | index() | ValueError | | | +-----------+------------+------------+------------+ Useful built-in exceptions: raise TypeError('Argument is of wrong type!') raise ValueError('Argument is of right type but inappropriate value!') raise RuntimeError('None of above!') User-defined Exceptions class MyError(Exception): pass class MyInputError(MyError): pass Exit Exits the interpreter by raising SystemExit exception. import sys sys.exit() # Exits with exit code 0 (success). sys.exit(&lt;int&gt;) # Exits with passed exit code. sys.exit(&lt;obj&gt;) # Prints the object and exits with 1 (failure). Print print(&lt;el_1&gt;, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) Use 'file=sys.stderr' for messages about errors. Use 'flush=True' to forcibly flush the stream. Pretty Print from pprint import pprint pprint(&lt;collection&gt;, width=80, depth=None, compact=False, sort_dicts=True) Levels deeper than 'depth' get replaced by '...'. Input Reads a line from user input or pipe if present. &lt;str&gt; = input(prompt=None) Trailing newline gets stripped. Prompt string is printed to the standard output before reading input. Raises EOFError when user hits EOF (ctrl-d) or input stream gets exhausted. Command Line Arguments import sys script_name = sys.argv[0] arguments = sys.argv[1:] Argparse from argparse import ArgumentParser, FileType p = ArgumentParser(description=&lt;str&gt;) p.add_argument('-&lt;short_name&gt;', '--&lt;name&gt;', action='store_true') # Flag p.add_argument('-&lt;short_name&gt;', '--&lt;name&gt;', type=&lt;type&gt;) # Option p.add_argument('&lt;name&gt;', type=&lt;type&gt;, nargs=1) # First argument p.add_argument('&lt;name&gt;', type=&lt;type&gt;, nargs='+') # Remaining arguments p.add_argument('&lt;name&gt;', type=&lt;type&gt;, nargs='*') # Optional arguments args = p.parse_args() # Exits on error. value = args.&lt;name&gt; Use 'help=&lt;str&gt;' to set argument description. Use 'default=&lt;el&gt;' to set the default value. Use 'type=FileType(&lt;mode&gt;)' for files. Open Opens the file and returns a corresponding file object. &lt;file&gt; = open('&lt;path&gt;', mode='r', encoding=None, newline=None) 'encoding=None' means that the default encoding is used, which is platform dependent. Best practice is to use 'encoding=&quot;utf-8&quot;' whenever possible. 'newline=None' means all different end of line combinations are converted to '\\n' on read, while on write all '\\n' characters are converted to system's default line separator. 'newline=&quot;&quot;' means no conversions take place, but input is still broken into chunks by readline() and readlines() on either '\\n', '\\r' or '\\r\\n'. Modes 'r' - Read (default). 'w' - Write (truncate). 'x' - Write or fail if the file already exists. 'a' - Append. 'w+' - Read and write (truncate). 'r+' - Read and write from the start. 'a+' - Read and write from the end. 't' - Text mode (default). 'b' - Binary mode. Exceptions 'FileNotFoundError' can be raised when reading with 'r' or 'r+'. 'FileExistsError' can be raised when writing with 'x'. 'IsADirectoryError' and 'PermissionError' can be raised by any. 'OSError' is the parent class of all listed exceptions. File Object &lt;file&gt;.seek(0) # Moves to the start of the file. &lt;file&gt;.seek(offset) # Moves 'offset' chars/bytes from the start. &lt;file&gt;.seek(0, 2) # Moves to the end of the file. &lt;bin_file&gt;.seek(±offset, &lt;anchor&gt;) # Anchor: 0 start, 1 current pos., 2 end. &lt;str/bytes&gt; = &lt;file&gt;.read(size=-1) # Reads 'size' chars/bytes or until EOF. &lt;str/bytes&gt; = &lt;file&gt;.readline() # Returns a line or empty string/bytes on EOF. &lt;list&gt; = &lt;file&gt;.readlines() # Returns a list of remaining lines. &lt;str/bytes&gt; = next(&lt;file&gt;) # Returns a line using buffer. Do not mix. &lt;file&gt;.write(&lt;str/bytes&gt;) # Writes a string or bytes object. &lt;file&gt;.writelines(&lt;collection&gt;) # Writes a coll. of strings or bytes objects. &lt;file&gt;.flush() # Flushes write buffer. Methods do not add or strip trailing newlines, even writelines(). Read Text from File def read_file(filename): with open(filename, encoding='utf-8') as file: return file.readlines() Write Text to File def write_to_file(filename, text): with open(filename, 'w', encoding='utf-8') as file: file.write(text) Path from os import getcwd, path, listdir from glob import glob &lt;str&gt; = getcwd() # Returns the current working directory. &lt;str&gt; = path.join(&lt;path&gt;, ...) # Joins two or more pathname components. &lt;str&gt; = path.abspath(&lt;path&gt;) # Returns absolute path. &lt;str&gt; = path.basename(&lt;path&gt;) # Returns final component of the path. &lt;str&gt; = path.dirname(&lt;path&gt;) # Returns path without the final component. &lt;tup.&gt; = path.splitext(&lt;path&gt;) # Splits on last period of the final component. &lt;list&gt; = listdir(path='.') # Returns filenames located at path. &lt;list&gt; = glob('&lt;pattern&gt;') # Returns paths matching the wildcard pattern. &lt;bool&gt; = path.exists(&lt;path&gt;) # Or: &lt;Path&gt;.exists() &lt;bool&gt; = path.isfile(&lt;path&gt;) # Or: &lt;DirEntry/Path&gt;.is_file() &lt;bool&gt; = path.isdir(&lt;path&gt;) # Or: &lt;DirEntry/Path&gt;.is_dir() DirEntry Using scandir() instead of listdir() can significantly increase the performance of code that also needs file type information. from os import scandir &lt;iter&gt; = scandir(path='.') # Returns DirEntry objects located at path. &lt;str&gt; = &lt;DirEntry&gt;.path # Returns path as a string. &lt;str&gt; = &lt;DirEntry&gt;.name # Returns final component as a string. &lt;file&gt; = open(&lt;DirEntry&gt;) # Opens the file and returns file object. Path Object from pathlib import Path &lt;Path&gt; = Path(&lt;path&gt; [, ...]) # Accepts strings, Paths and DirEntry objects. &lt;Path&gt; = &lt;path&gt; / &lt;path&gt; [/ ...] # One of the paths must be a Path object. &lt;Path&gt; = Path() # Returns relative cwd. Also Path('.'). &lt;Path&gt; = Path.cwd() # Returns absolute cwd. Also Path().resolve(). &lt;Path&gt; = &lt;Path&gt;.resolve() # Returns absolute Path without symlinks. &lt;Path&gt; = &lt;Path&gt;.parent # Returns Path without final component. &lt;str&gt; = &lt;Path&gt;.name # Returns final component as a string. &lt;str&gt; = &lt;Path&gt;.stem # Returns final component without extension. &lt;str&gt; = &lt;Path&gt;.suffix # Returns final component's extension. &lt;tup.&gt; = &lt;Path&gt;.parts # Returns all components as strings. &lt;iter&gt; = &lt;Path&gt;.iterdir() # Returns dir contents as Path objects. &lt;iter&gt; = &lt;Path&gt;.glob('&lt;pattern&gt;') # Returns Paths matching the wildcard pattern. &lt;str&gt; = str(&lt;Path&gt;) # Returns path as a string. &lt;file&gt; = open(&lt;Path&gt;) # Opens the file and returns file object. OS Commands Files and Directories Paths can be either strings, Paths or DirEntry objects. Functions report OS related errors by raising either OSError or one of its subclasses. import os, shutil os.chdir(&lt;path&gt;) # Changes the current working directory. os.mkdir(&lt;path&gt;, mode=0o777) # Creates a directory. Mode is in octal. shutil.copy(from, to) # Copies the file. 'to' can be a directory. shutil.copytree(from, to) # Copies the directory. 'to' must not exist. os.rename(from, to) # Renames/moves the file or directory. os.replace(from, to) # Same, but overwrites 'to' if it exists. os.remove(&lt;path&gt;) # Deletes the file. os.rmdir(&lt;path&gt;) # Deletes the empty directory. shutil.rmtree(&lt;path&gt;) # Deletes the directory. Shell Commands import os &lt;str&gt; = os.popen('&lt;shell_command&gt;').read() Sends '1 + 1' to the calculator and captures its output: &gt;&gt;&gt; from subprocess import run &gt;&gt;&gt; run('bc', input='1 + 1\\n', capture_output=True, encoding='utf-8') CompletedProcess(args='bc', returncode=0, stdout='2\\n', stderr='') Sends test.in to the calculator running in standard mode and saves its output to test.out: &gt;&gt;&gt; from shlex import split &gt;&gt;&gt; os.popen('echo 1 + 1 &gt; test.in') &gt;&gt;&gt; run(split('bc -s'), stdin=open('test.in'), stdout=open('test.out', 'w')) CompletedProcess(args=['bc', '-s'], returncode=0) &gt;&gt;&gt; open('test.out').read() '2\\n' JSON Text file format for storing collections of strings and numbers. import json &lt;str&gt; = json.dumps(&lt;object&gt;, ensure_ascii=True, indent=None) &lt;object&gt; = json.loads(&lt;str&gt;) Read Object from JSON File def read_json_file(filename): with open(filename, encoding='utf-8') as file: return json.load(file) Write Object to JSON File def write_to_json_file(filename, an_object): with open(filename, 'w', encoding='utf-8') as file: json.dump(an_object, file, ensure_ascii=False, indent=2) Pickle Binary file format for storing objects. import pickle &lt;bytes&gt; = pickle.dumps(&lt;object&gt;) &lt;object&gt; = pickle.loads(&lt;bytes&gt;) Read Object from File def read_pickle_file(filename): with open(filename, 'rb') as file: return pickle.load(file) Write Object to File def write_to_pickle_file(filename, an_object): with open(filename, 'wb') as file: pickle.dump(an_object, file) CSV Text file format for storing spreadsheets. import csv Read &lt;reader&gt; = csv.reader(&lt;file&gt;, dialect='excel', delimiter=',') &lt;list&gt; = next(&lt;reader&gt;) # Returns next row as a list of strings. &lt;list&gt; = list(&lt;reader&gt;) # Returns list of remaining rows. File must be opened with 'newline=&quot;&quot;' argument, or newlines embedded inside quoted fields will not be interpreted correctly! Write &lt;writer&gt; = csv.writer(&lt;file&gt;, dialect='excel', delimiter=',') &lt;writer&gt;.writerow(&lt;collection&gt;) # Encodes objects using `str(&lt;el&gt;)`. &lt;writer&gt;.writerows(&lt;coll_of_coll&gt;) # Appends multiple rows. File must be opened with 'newline=&quot;&quot;' argument, or an extra '\\r' will be added to every '\\n' on platforms that use '\\r\\n' line endings! Parameters 'dialect' - Master parameter that sets the default values. 'delimiter' - A one-character string used to separate fields. 'quotechar' - Character for quoting fields that contain special characters. 'doublequote' - Whether quotechars inside fields get doubled or escaped. 'skipinitialspace' - Whether whitespace after delimiter gets stripped. 'lineterminator' - Specifies how writer terminates rows. 'quoting' - Controls the amount of quoting: 0 - as necessary, 1 - all. 'escapechar' - Character for escaping 'quotechar' if 'doublequote' is False. Dialects +------------------+--------------+--------------+--------------+ | | excel | excel-tab | unix | +------------------+--------------+--------------+--------------+ | delimiter | ',' | '\\t' | ',' | | quotechar | '&quot;' | '&quot;' | '&quot;' | | doublequote | True | True | True | | skipinitialspace | False | False | False | | lineterminator | '\\r\\n' | '\\r\\n' | '\\n' | | quoting | 0 | 0 | 1 | | escapechar | None | None | None | +------------------+--------------+--------------+--------------+ Read Rows from CSV File def read_csv_file(filename): with open(filename, encoding='utf-8', newline='') as file: return list(csv.reader(file)) Write Rows to CSV File def write_to_csv_file(filename, rows): with open(filename, 'w', encoding='utf-8', newline='') as file: writer = csv.writer(file) writer.writerows(rows) SQLite Server-less database engine that stores each database into a separate file. Connect Opens a connection to the database file. Creates a new file if path doesn't exist. import sqlite3 db = sqlite3.connect('&lt;path&gt;') # Also ':memory:'. ... db.close() Read Returned values can be of type str, int, float, bytes or None. &lt;cursor&gt; = db.execute('&lt;query&gt;') # Can raise a subclass of sqlite3.Error. &lt;tuple&gt; = &lt;cursor&gt;.fetchone() # Returns next row. Also next(&lt;cursor&gt;). &lt;list&gt; = &lt;cursor&gt;.fetchall() # Returns remaining rows. Also list(&lt;cursor&gt;). Write db.execute('&lt;query&gt;') db.commit() Or: with db: db.execute('&lt;query&gt;') Placeholders Passed values can be of type str, int, float, bytes, None, bool, datetime.date or datetime.datetme. Bools will be stored and returned as ints and dates as ISO formatted strings. db.execute('&lt;query&gt;', &lt;list/tuple&gt;) # Replaces '?'s in query with values. db.execute('&lt;query&gt;', &lt;dict/namedtuple&gt;) # Replaces ':&lt;key&gt;'s with values. db.executemany('&lt;query&gt;', &lt;coll_of_above&gt;) # Runs execute() many times. Example In this example values are not actually saved because 'db.commit()' is omitted! &gt;&gt;&gt; db = sqlite3.connect('test.db') &gt;&gt;&gt; db.execute('create table t (a, b, c)') &gt;&gt;&gt; db.execute('insert into t values (1, 2, 3)') &gt;&gt;&gt; db.execute('select * from t').fetchall() [(1, 2, 3)] MySQL Has a very similar interface, with differences listed below. # $ pip3 install mysql-connector from mysql import connector db = connector.connect(host=&lt;str&gt;, user=&lt;str&gt;, password=&lt;str&gt;, database=&lt;str&gt;) &lt;cursor&gt; = db.cursor() &lt;cursor&gt;.execute('&lt;query&gt;') # Can raise a subclass of connector.Error. &lt;cursor&gt;.execute('&lt;query&gt;', &lt;list/tuple&gt;) # Replaces '%s's in query with values. &lt;cursor&gt;.execute('&lt;query&gt;', &lt;dict/namedtuple&gt;) # Replaces '%(&lt;key&gt;)s's with values. Bytes Bytes object is an immutable sequence of single bytes. Mutable version is called bytearray. &lt;bytes&gt; = b'&lt;str&gt;' # Only accepts ASCII characters and \\x00 - \\xff. &lt;int&gt; = &lt;bytes&gt;[&lt;index&gt;] # Returns int in range from 0 to 255. &lt;bytes&gt; = &lt;bytes&gt;[&lt;slice&gt;] # Returns bytes even if it has only one element. &lt;bytes&gt; = &lt;bytes&gt;.join(&lt;coll_of_bytes&gt;) # Joins elements using bytes object as separator. Encode &lt;bytes&gt; = bytes(&lt;coll_of_ints&gt;) # Ints must be in range from 0 to 255. &lt;bytes&gt; = bytes(&lt;str&gt;, 'utf-8') # Or: &lt;str&gt;.encode('utf-8') &lt;bytes&gt; = &lt;int&gt;.to_bytes(n_bytes, byteorder='big/little', signed=False) &lt;bytes&gt; = bytes.fromhex('&lt;hex&gt;') Decode &lt;list&gt; = list(&lt;bytes&gt;) # Returns ints in range from 0 to 255. &lt;str&gt; = str(&lt;bytes&gt;, 'utf-8') # Or: &lt;bytes&gt;.decode('utf-8') &lt;int&gt; = int.from_bytes(&lt;bytes&gt;, byteorder='big/little', signed=False) '&lt;hex&gt;' = &lt;bytes&gt;.hex() Read Bytes from File def read_bytes(filename): with open(filename, 'rb') as file: return file.read() Write Bytes to File def write_bytes(filename, bytes_obj): with open(filename, 'wb') as file: file.write(bytes_obj) Struct Module that performs conversions between a sequence of numbers and a bytes object. Machine’s native type sizes and byte order are used by default. from struct import pack, unpack, iter_unpack &lt;bytes&gt; = pack('&lt;format&gt;', &lt;num_1&gt; [, &lt;num_2&gt;, ...]) &lt;tuple&gt; = unpack('&lt;format&gt;', &lt;bytes&gt;) &lt;tuples&gt; = iter_unpack('&lt;format&gt;', &lt;bytes&gt;) Example &gt;&gt;&gt; pack('&gt;hhl', 1, 2, 3) b'\\x00\\x01\\x00\\x02\\x00\\x00\\x00\\x03' &gt;&gt;&gt; unpack('&gt;hhl', b'\\x00\\x01\\x00\\x02\\x00\\x00\\x00\\x03') (1, 2, 3) Format For standard type sizes start format string with: '=' - native byte order '&lt;' - little-endian '&gt;' - big-endian (also '!') Integer types. Use a capital letter for unsigned type. Standard sizes are in brackets: 'x' - pad byte 'b' - char (1) 'h' - short (2) 'i' - int (4) 'l' - long (4) 'q' - long long (8) Floating point types: 'f' - float (4) 'd' - double (8) Array List that can only hold numbers of a predefined type. Available types and their sizes in bytes are listed above. from array import array &lt;array&gt; = array('&lt;typecode&gt;', &lt;collection&gt;) # Array from collection of numbers. &lt;array&gt; = array('&lt;typecode&gt;', &lt;bytes&gt;) # Array from bytes object. &lt;array&gt; = array('&lt;typecode&gt;', &lt;array&gt;) # Treats array as a sequence of numbers. &lt;bytes&gt; = bytes(&lt;array&gt;) # Or: &lt;array&gt;.tobytes() Memory View A sequence object that points to the memory of another object. Each element can reference a single or multiple consecutive bytes, depending on format. Order and number of elements can be changed with slicing. &lt;mview&gt; = memoryview(&lt;bytes/bytearray/array&gt;) # Immutable if bytes, else mutable. &lt;real&gt; = &lt;mview&gt;[&lt;index&gt;] # Returns an int or a float. &lt;mview&gt; = &lt;mview&gt;[&lt;slice&gt;] # Mview with rearranged elements. &lt;mview&gt; = &lt;mview&gt;.cast('&lt;typecode&gt;') # Casts memoryview to the new format. &lt;mview&gt;.release() # Releases the object's memory buffer. Decode &lt;bin_file&gt;.write(&lt;mview&gt;) # Writes mview to the binary file. &lt;bytes&gt; = bytes(&lt;mview&gt;) # Creates a new bytes object. &lt;bytes&gt; = &lt;bytes&gt;.join(&lt;coll_of_mviews&gt;) # Joins mviews using bytes object as sep. &lt;array&gt; = array('&lt;typecode&gt;', &lt;mview&gt;) # Treats mview as a sequence of numbers. &lt;list&gt; = list(&lt;mview&gt;) # Returns list of ints or floats. &lt;str&gt; = str(&lt;mview&gt;, 'utf-8') # Treats mview as a bytes object. &lt;int&gt; = int.from_bytes(&lt;mview&gt;, byteorder='big/little', signed=False) '&lt;hex&gt;' = &lt;mview&gt;.hex() Deque A thread-safe list with efficient appends and pops from either side. Pronounced &quot;deck&quot;. from collections import deque &lt;deque&gt; = deque(&lt;collection&gt;, maxlen=None) &lt;deque&gt;.appendleft(&lt;el&gt;) # Opposite element is dropped if full. &lt;deque&gt;.extendleft(&lt;collection&gt;) # Collection gets reversed. &lt;el&gt; = &lt;deque&gt;.popleft() # Raises IndexError if empty. &lt;deque&gt;.rotate(n=1) # Rotates elements to the right. Threading CPython interpreter can only run a single thread at a time. That is why using multiple threads won't result in a faster execution, unless at least one of the threads contains an I/O operation. from threading import Thread, RLock, Semaphore, Event, Barrier Thread thread = Thread(target=&lt;function&gt;, args=(&lt;first_arg&gt;, )) thread.start() ... &lt;bool&gt; = thread.is_alive() # Checks if thread has finished executing. thread.join() # Waits for thread to finish. Use 'kwargs=&lt;dict&gt;' to pass keyword arguments to the function. Use 'daemon=True', or the program will not be able to exit while the thread is alive. Lock lock = RLock() lock.acquire() # Waits for lock to be available. ... lock.release() Or: lock = RLock() with lock: ... Semaphore, Event, Barrier &lt;Semaphore&gt; = Semaphore(value=1) # Lock that can be acquired 'value' times. &lt;Event&gt; = Event() # Method wait() blocks until set() is called. &lt;Barrier&gt; = Barrier(n_times) # Method wait() blocks until it's called 'n_times'. Thread Pool Executor from concurrent.futures import ThreadPoolExecutor with ThreadPoolExecutor(max_workers=None) as executor: &lt;iter&gt; = executor.map(lambda x: x + 1, range(3)) # (1, 2, 3) &lt;iter&gt; = executor.map(lambda x, y: x + y, 'abc', '123') # ('a1', 'b2', 'c3') &lt;Future&gt; = executor.submit(&lt;function&gt; [, &lt;arg_1&gt;, ...]) Future: &lt;bool&gt; = &lt;Future&gt;.done() # Checks if thread has finished executing. &lt;obj&gt; = &lt;Future&gt;.result() # Waits for thread to finish and returns result. Queue A thread-safe FIFO queue. For LIFO queue use LifoQueue. from queue import Queue &lt;Queue&gt; = Queue(maxsize=0) &lt;Queue&gt;.put(&lt;el&gt;) # Blocks until queue stops being full. &lt;Queue&gt;.put_nowait(&lt;el&gt;) # Raises queue.Full exception if full. &lt;el&gt; = &lt;Queue&gt;.get() # Blocks until queue stops being empty. &lt;el&gt; = &lt;Queue&gt;.get_nowait() # Raises queue.Empty exception if empty. Operator Module of functions that provide the functionality of operators. from operator import add, sub, mul, truediv, floordiv, mod, pow, neg, abs from operator import eq, ne, lt, le, gt, ge from operator import and_, or_, not_ from operator import itemgetter, attrgetter, methodcaller import operator as op elementwise_sum = map(op.add, list_a, list_b) sorted_by_second = sorted(&lt;collection&gt;, key=op.itemgetter(1)) sorted_by_both = sorted(&lt;collection&gt;, key=op.itemgetter(1, 0)) product_of_elems = functools.reduce(op.mul, &lt;collection&gt;) LogicOp = enum.Enum('LogicOp', {'AND': op.and_, 'OR' : op.or_}) last_el = op.methodcaller('pop')(&lt;list&gt;) Introspection Inspecting code at runtime. Variables &lt;list&gt; = dir() # Returns names of local variables (incl. functions). &lt;dict&gt; = vars() # Returns dict of local variables. Also locals(). &lt;dict&gt; = globals() # Returns dict of global variables. Attributes &lt;list&gt; = dir(&lt;object&gt;) # Returns names of object's attributes (incl. methods). &lt;dict&gt; = vars(&lt;object&gt;) # Returns dict of object's fields. Also &lt;obj&gt;.__dict__. &lt;bool&gt; = hasattr(&lt;object&gt;, '&lt;attr_name&gt;') value = getattr(&lt;object&gt;, '&lt;attr_name&gt;') setattr(&lt;object&gt;, '&lt;attr_name&gt;', value) delattr(&lt;object&gt;, '&lt;attr_name&gt;') Parameters from inspect import signature &lt;sig&gt; = signature(&lt;function&gt;) no_of_params = len(&lt;sig&gt;.parameters) param_names = list(&lt;sig&gt;.parameters.keys()) param_kinds = [a.kind for a in &lt;sig&gt;.parameters.values()] Metaprograming Code that generates code. Type Type is the root class. If only passed an object it returns its type (class). Otherwise it creates a new class. &lt;class&gt; = type('&lt;class_name&gt;', &lt;parents_tuple&gt;, &lt;attributes_dict&gt;) &gt;&gt;&gt; Z = type('Z', (), {'a': 'abcde', 'b': 12345}) &gt;&gt;&gt; z = Z() Meta Class A class that creates classes. def my_meta_class(name, parents, attrs): attrs['a'] = 'abcde' return type(name, parents, attrs) Or: class MyMetaClass(type): def __new__(cls, name, parents, attrs): attrs['a'] = 'abcde' return type.__new__(cls, name, parents, attrs) New() is a class method that gets called before init(). If it returns an instance of its class, then that instance gets passed to init() as a 'self' argument. It receives the same arguments as init(), except for the first one that specifies the desired type of the returned instance (MyMetaClass in our case). Like in our case, new() can also be called directly, usually from a new() method of a child class (def __new__(cls): return super().__new__(cls)). The only difference between the examples above is that my_meta_class() returns a class of type type, while MyMetaClass() returns a class of type MyMetaClass. Metaclass Attribute Right before a class is created it checks if it has a 'metaclass' attribute defined. If not, it recursively checks if any of his parents has it defined and eventually comes to type(). class MyClass(metaclass=MyMetaClass): b = 12345 &gt;&gt;&gt; MyClass.a, MyClass.b ('abcde', 12345) Type Diagram type(MyClass) == MyMetaClass # MyClass is an instance of MyMetaClass. type(MyMetaClass) == type # MyMetaClass is an instance of type. +-------------+-------------+ | Classes | Metaclasses | +-------------+-------------| | MyClass --&gt; MyMetaClass | | | v | | object -----&gt; type &lt;+ | | | ^ +---+ | | str ---------+ | +-------------+-------------+ Inheritance Diagram MyClass.__base__ == object # MyClass is a subclass of object. MyMetaClass.__base__ == type # MyMetaClass is a subclass of type. +-------------+-------------+ | Classes | Metaclasses | +-------------+-------------| | MyClass | MyMetaClass | | v | v | | object &lt;----- type | | ^ | | | str | | +-------------+-------------+ Eval &gt;&gt;&gt; from ast import literal_eval &gt;&gt;&gt; literal_eval('1 + 2') 3 &gt;&gt;&gt; literal_eval('[1, 2, 3]') [1, 2, 3] &gt;&gt;&gt; literal_eval('abs(1)') ValueError: malformed node or string Coroutines Coroutines have a lot in common with threads, but unlike threads, they only give up control when they call another coroutine and they don’t use as much memory. Coroutine definition starts with 'async' and its call with 'await'. 'asyncio.run(&lt;coroutine&gt;)' is the main entry point for asynchronous programs. Functions wait(), gather() and as_completed() can be used when multiple coroutines need to be started at the same time. Asyncio module also provides its own Queue, Event, Lock and Semaphore classes. Runs a terminal game where you control an asterisk that must avoid numbers: import asyncio, collections, curses, enum, random P = collections.namedtuple('P', 'x y') # Position D = enum.Enum('D', 'n e s w') # Direction def main(screen): curses.curs_set(0) # Makes cursor invisible. screen.nodelay(True) # Makes getch() non-blocking. asyncio.run(main_coroutine(screen)) # Starts running asyncio code. async def main_coroutine(screen): state = {'*': P(0, 0), **{id_: P(30, 10) for id_ in range(10)}} moves = asyncio.Queue() coros = (*(random_controller(id_, moves) for id_ in range(10)), human_controller(screen, moves), model(moves, state, *screen.getmaxyx()), view(state, screen)) await asyncio.wait(coros, return_when=asyncio.FIRST_COMPLETED) async def random_controller(id_, moves): while True: moves.put_nowait((id_, random.choice(list(D)))) await asyncio.sleep(random.random() / 2) async def human_controller(screen, moves): while True: ch = screen.getch() key_mappings = {259: D.n, 261: D.e, 258: D.s, 260: D.w} if ch in key_mappings: moves.put_nowait(('*', key_mappings[ch])) await asyncio.sleep(0.01) async def model(moves, state, height, width): while state['*'] not in {p for id_, p in state.items() if id_ != '*'}: id_, d = await moves.get() p = state[id_] deltas = {D.n: P(0, -1), D.e: P(1, 0), D.s: P(0, 1), D.w: P(-1, 0)} new_p = P(*[sum(a) for a in zip(p, deltas[d])]) if 0 &lt;= new_p.x &lt; width-1 and 0 &lt;= new_p.y &lt; height: state[id_] = new_p async def view(state, screen): while True: screen.clear() for id_, p in state.items(): screen.addstr(p.y, p.x, str(id_)) await asyncio.sleep(0.01) curses.wrapper(main) Libraries Progress Bar # $ pip3 install tqdm from tqdm import tqdm from time import sleep for el in tqdm([1, 2, 3]): sleep(0.2) Plot # $ pip3 install matplotlib from matplotlib import pyplot pyplot.plot(&lt;y_data&gt; [, label=&lt;str&gt;]) pyplot.plot(&lt;x_data&gt;, &lt;y_data&gt;) pyplot.legend() # Adds a legend. pyplot.savefig('&lt;path&gt;') # Saves the figure. pyplot.show() # Displays the figure. pyplot.clf() # Clears the figure. Table Prints a CSV file as an ASCII table: # $ pip3 install tabulate import csv, tabulate with open('test.csv', encoding='utf-8', newline='') as file: rows = csv.reader(file) header = [a.title() for a in next(rows)] table = tabulate.tabulate(rows, header) print(table) Curses Clears the terminal, prints a message and waits for the ESC key press: from curses import wrapper, curs_set, ascii from curses import KEY_UP, KEY_RIGHT, KEY_DOWN, KEY_LEFT def main(): wrapper(draw) def draw(screen): curs_set(0) # Makes cursor invisible. screen.nodelay(True) # Makes getch() non-blocking. screen.clear() screen.addstr(0, 0, 'Press ESC to quit.') while screen.getch() != ascii.ESC: pass def get_border(screen): from collections import namedtuple P = namedtuple('P', 'x y') height, width = screen.getmaxyx() return P(width - 1, height - 1) if __name__ == '__main__': main() Logging # $ pip3 install loguru from loguru import logger logger.add('debug_{time}.log', colorize=True) # Connects a log file. logger.add('error_{time}.log', level='ERROR') # Another file for errors or higher. logger.&lt;level&gt;('A logging message.') Levels: 'debug', 'info', 'success', 'warning', 'error', 'critical'. Exceptions Exception description, stack trace and values of variables are appended automatically. try: ... except &lt;exception&gt;: logger.exception('An error happened.') Rotation Argument that sets a condition when a new log file is created. rotation=&lt;int&gt;|&lt;datetime.timedelta&gt;|&lt;datetime.time&gt;|&lt;str&gt; '&lt;int&gt;' - Max file size in bytes. '&lt;timedelta&gt;' - Max age of a file. '&lt;time&gt;' - Time of day. '&lt;str&gt;' - Any of above as a string: '100 MB', '1 month', 'monday at 12:00', ... Retention Sets a condition which old log files get deleted. retention=&lt;int&gt;|&lt;datetime.timedelta&gt;|&lt;str&gt; '&lt;int&gt;' - Max number of files. '&lt;timedelta&gt;' - Max age of a file. '&lt;str&gt;' - Max age as a string: '1 week, 3 days', '2 months', ... Scraping Scrapes Python's URL, version number and logo from Wikipedia page: # $ pip3 install requests beautifulsoup4 import requests from bs4 import BeautifulSoup URL = 'https://en.wikipedia.org/wiki/Python_(programming_language)' try: html = requests.get(URL).text doc = BeautifulSoup(html, 'html.parser') table = doc.find('table', class_='infobox vevent') rows = table.find_all('tr') link = rows[11].find('a')['href'] ver = rows[6].find('div').text.split()[0] url_i = rows[0].find('img')['src'] image = requests.get(f'https:{url_i}').content with open('test.png', 'wb') as file: file.write(image) print(link, ver) except requests.exceptions.ConnectionError: print(&quot;You've got problems with connection.&quot;) Web # $ pip3 install bottle from bottle import run, route, static_file, template, post, request, response import json Run run(host='localhost', port=8080) # Runs locally. run(host='0.0.0.0', port=80) # Runs globally. Static Request @route('/img/&lt;image&gt;') def send_image(image): return static_file(image, 'img_dir/', mimetype='image/png') Dynamic Request @route('/&lt;sport&gt;') def send_page(sport): return template('&lt;h1&gt;{{title}}&lt;/h1&gt;', title=sport) REST Request @post('/odds/&lt;sport&gt;') def odds_handler(sport): team = request.forms.get('team') home_odds, away_odds = 2.44, 3.29 response.headers['Content-Type'] = 'application/json' response.headers['Cache-Control'] = 'no-cache' return json.dumps([team, home_odds, away_odds]) Test: # $ pip3 install requests &gt;&gt;&gt; import requests &gt;&gt;&gt; url = 'http://localhost:8080/odds/football' &gt;&gt;&gt; data = {'team': 'arsenal f.c.'} &gt;&gt;&gt; response = requests.post(url, data=data) &gt;&gt;&gt; response.json() ['arsenal f.c.', 2.44, 3.29] Profiling Stopwatch from time import time start_time = time() # Seconds since the Epoch. ... duration = time() - start_time High performance: from time import perf_counter start_time = perf_counter() # Seconds since restart. ... duration = perf_counter() - start_time Timing a Snippet &gt;&gt;&gt; from timeit import timeit &gt;&gt;&gt; timeit('&quot;-&quot;.join(str(a) for a in range(100))', ... number=10000, globals=globals(), setup='pass') 0.34986 Profiling by Line # $ pip3 install line_profiler memory_profiler @profile def main(): a = [*range(10000)] b = {*range(10000)} main() $ kernprof -lv test.py Line # Hits Time Per Hit % Time Line Contents ======================================================= 1 @profile 2 def main(): 3 1 1128.0 1128.0 27.4 a = [*range(10000)] 4 1 2994.0 2994.0 72.6 b = {*range(10000)} $ python3 -m memory_profiler test.py Line # Mem usage Increment Line Contents ======================================================= 1 35.387 MiB 35.387 MiB @profile 2 def main(): 3 35.734 MiB 0.348 MiB a = [*range(10000)] 4 36.160 MiB 0.426 MiB b = {*range(10000)} Call Graph Generates a PNG image of a call graph with highlighted bottlenecks: # $ pip3 install pycallgraph from pycallgraph import output, PyCallGraph from datetime import datetime time_str = datetime.now().strftime('%Y%m%d%H%M%S') filename = f'profile-{time_str}.png' drawer = output.GraphvizOutput(output_file=filename) with PyCallGraph(drawer): &lt;code_to_be_profiled&gt; NumPy Array manipulation mini-language. It can run up to one hundred times faster than the equivalent Python code. # $ pip3 install numpy import numpy as np &lt;array&gt; = np.array(&lt;list&gt;) &lt;array&gt; = np.arange(from_inclusive, to_exclusive, ±step_size) &lt;array&gt; = np.ones(&lt;shape&gt;) &lt;array&gt; = np.random.randint(from_inclusive, to_exclusive, &lt;shape&gt;) &lt;array&gt;.shape = &lt;shape&gt; &lt;view&gt; = &lt;array&gt;.reshape(&lt;shape&gt;) &lt;view&gt; = np.broadcast_to(&lt;array&gt;, &lt;shape&gt;) &lt;array&gt; = &lt;array&gt;.sum(axis) indexes = &lt;array&gt;.argmin(axis) Shape is a tuple of dimension sizes. Axis is the index of a dimension that gets collapsed. The leftmost dimension has index 0. Indexing &lt;el&gt; = &lt;2d_array&gt;[0, 0] # First element. &lt;1d_view&gt; = &lt;2d_array&gt;[0] # First row. &lt;1d_view&gt; = &lt;2d_array&gt;[:, 0] # First column. Also [..., 0]. &lt;3d_view&gt; = &lt;2d_array&gt;[None, :, :] # Expanded by dimension of size 1. &lt;1d_array&gt; = &lt;2d_array&gt;[&lt;1d_row_indexes&gt;, &lt;1d_column_indexes&gt;] &lt;2d_array&gt; = &lt;2d_array&gt;[&lt;2d_row_indexes&gt;, &lt;2d_column_indexes&gt;] &lt;2d_bools&gt; = &lt;2d_array&gt; &gt; 0 &lt;1d_array&gt; = &lt;2d_array&gt;[&lt;2d_bools&gt;] If row and column indexes differ in shape, they are combined with broadcasting. Broadcasting Broadcasting is a set of rules by which NumPy functions operate on arrays of different sizes and/or dimensions. left = [[0.1], [0.6], [0.8]] # Shape: (3, 1) right = [ 0.1 , 0.6 , 0.8 ] # Shape: (3) 1. If array shapes differ in length, left-pad the shorter shape with ones: left = [[0.1], [0.6], [0.8]] # Shape: (3, 1) right = [[0.1 , 0.6 , 0.8]] # Shape: (1, 3) &lt;- ! 2. If any dimensions differ in size, expand the ones that have size 1 by duplicating their elements: left = [[0.1, 0.1, 0.1], [0.6, 0.6, 0.6], [0.8, 0.8, 0.8]] # Shape: (3, 3) &lt;- ! right = [[0.1, 0.6, 0.8], [0.1, 0.6, 0.8], [0.1, 0.6, 0.8]] # Shape: (3, 3) &lt;- ! 3. If neither non-matching dimension has size 1, raise an error. Example For each point returns index of its nearest point ([0.1, 0.6, 0.8] =&gt; [1, 2, 1]): &gt;&gt;&gt; points = np.array([0.1, 0.6, 0.8]) [ 0.1, 0.6, 0.8] &gt;&gt;&gt; wrapped_points = points.reshape(3, 1) [[ 0.1], [ 0.6], [ 0.8]] &gt;&gt;&gt; distances = wrapped_points - points [[ 0. , -0.5, -0.7], [ 0.5, 0. , -0.2], [ 0.7, 0.2, 0. ]] &gt;&gt;&gt; distances = np.abs(distances) [[ 0. , 0.5, 0.7], [ 0.5, 0. , 0.2], [ 0.7, 0.2, 0. ]] &gt;&gt;&gt; i = np.arange(3) [0, 1, 2] &gt;&gt;&gt; distances[i, i] = np.inf [[ inf, 0.5, 0.7], [ 0.5, inf, 0.2], [ 0.7, 0.2, inf]] &gt;&gt;&gt; distances.argmin(1) [1, 2, 1] Image # $ pip3 install pillow from PIL import Image &lt;Image&gt; = Image.new('&lt;mode&gt;', (width, height)) &lt;Image&gt; = Image.open('&lt;path&gt;') &lt;Image&gt; = &lt;Image&gt;.convert('&lt;mode&gt;') &lt;Image&gt;.save('&lt;path&gt;') &lt;Image&gt;.show() &lt;tuple/int&gt; = &lt;Image&gt;.getpixel((x, y)) # Returns a pixel. &lt;Image&gt;.putpixel((x, y), &lt;tuple/int&gt;) # Writes a pixel to the image. &lt;ImagingCore&gt; = &lt;Image&gt;.getdata() # Returns a sequence of pixels. &lt;Image&gt;.putdata(&lt;list/ImagingCore&gt;) # Writes a sequence of pixels. &lt;Image&gt;.paste(&lt;Image&gt;, (x, y)) # Writes an image to the image. &lt;2d_array&gt; = np.array(&lt;Image&gt;) # Creates NumPy array from greyscale image. &lt;3d_array&gt; = np.array(&lt;Image&gt;) # Creates NumPy array from color image. &lt;Image&gt; = Image.fromarray(&lt;array&gt;) # Creates image from NumPy array of floats. Modes '1' - 1-bit pixels, black and white, stored with one pixel per byte. 'L' - 8-bit pixels, greyscale. 'RGB' - 3x8-bit pixels, true color. 'RGBA' - 4x8-bit pixels, true color with transparency mask. 'HSV' - 3x8-bit pixels, Hue, Saturation, Value color space. Examples Creates a PNG image of a rainbow gradient: WIDTH, HEIGHT = 100, 100 size = WIDTH * HEIGHT hues = [255 * i/size for i in range(size)] img = Image.new('HSV', (WIDTH, HEIGHT)) img.putdata([(int(h), 255, 255) for h in hues]) img.convert('RGB').save('test.png') Adds noise to a PNG image: from random import randint add_noise = lambda value: max(0, min(255, value + randint(-20, 20))) img = Image.open('test.png').convert('HSV') img.putdata([(add_noise(h), s, v) for h, s, v in img.getdata()]) img.convert('RGB').save('test.png') Drawing from PIL import ImageDraw &lt;ImageDraw&gt; = ImageDraw.Draw(&lt;Image&gt;) &lt;ImageDraw&gt;.point((x, y), fill=None) &lt;ImageDraw&gt;.line((x1, y1, x2, y2 [, ...]), fill=None, width=0, joint=None) &lt;ImageDraw&gt;.arc((x1, y1, x2, y2), from_deg, to_deg, fill=None, width=0) &lt;ImageDraw&gt;.rectangle((x1, y1, x2, y2), fill=None, outline=None, width=0) &lt;ImageDraw&gt;.polygon((x1, y1, x2, y2 [, ...]), fill=None, outline=None) &lt;ImageDraw&gt;.ellipse((x1, y1, x2, y2), fill=None, outline=None, width=0) Use 'fill=&lt;color&gt;' to set the primary color. Use 'outline=&lt;color&gt;' to set the secondary color. Color can be specified as a tuple, int, '#rrggbb' string or a color name. Animation Creates a GIF of a bouncing ball: # $ pip3 install pillow imageio from PIL import Image, ImageDraw import imageio WIDTH, R = 126, 10 frames = [] for velocity in range(15): y = sum(range(velocity+1)) frame = Image.new('L', (WIDTH, WIDTH)) draw = ImageDraw.Draw(frame) draw.ellipse((WIDTH/2-R, y, WIDTH/2+R, y+2*R), fill='white') frames.append(frame) frames += reversed(frames[1:-1]) imageio.mimsave('test.gif', frames, duration=0.03) Audio import wave &lt;Wave_read&gt; = wave.open('&lt;path&gt;', 'rb') # Opens the WAV file. framerate = &lt;Wave_read&gt;.getframerate() # Number of frames per second. nchannels = &lt;Wave_read&gt;.getnchannels() # Number of samples per frame. sampwidth = &lt;Wave_read&gt;.getsampwidth() # Sample size in bytes. nframes = &lt;Wave_read&gt;.getnframes() # Number of frames. &lt;params&gt; = &lt;Wave_read&gt;.getparams() # Immutable collection of above. &lt;bytes&gt; = &lt;Wave_read&gt;.readframes(nframes) # Returns next 'nframes' frames. &lt;Wave_write&gt; = wave.open('&lt;path&gt;', 'wb') # Truncates existing file. &lt;Wave_write&gt;.setframerate(&lt;int&gt;) # 44100 for CD, 48000 for video. &lt;Wave_write&gt;.setnchannels(&lt;int&gt;) # 1 for mono, 2 for stereo. &lt;Wave_write&gt;.setsampwidth(&lt;int&gt;) # 2 for CD quality sound. &lt;Wave_write&gt;.setparams(&lt;params&gt;) # Sets all parameters. &lt;Wave_write&gt;.writeframes(&lt;bytes&gt;) # Appends frames to file. Bytes object contains a sequence of frames, each consisting of one or more samples. In a stereo signal, the first sample of a frame belongs to the left channel. Each sample consists of one or more bytes that, when converted to an integer, indicate the displacement of a speaker membrane at a given moment. If sample width is one, then the integer should be encoded unsigned. For all other sizes, the integer should be encoded signed with little-endian byte order. Sample Values +-----------+-------------+------+-------------+ | sampwidth | min | zero | max | +-----------+-------------+------+-------------+ | 1 | 0 | 128 | 255 | | 2 | -32768 | 0 | 32767 | | 3 | -8388608 | 0 | 8388607 | | 4 | -2147483648 | 0 | 2147483647 | +-----------+-------------+------+-------------+ Read Float Samples from WAV File def read_wav_file(filename): def get_int(a_bytes): an_int = int.from_bytes(a_bytes, 'little', signed=width!=1) return an_int - 128 * (width == 1) with wave.open(filename, 'rb') as file: width = file.getsampwidth() frames = file.readframes(file.getnframes()) byte_samples = (frames[i: i + width] for i in range(0, len(frames), width)) return [get_int(b) / pow(2, width * 8 - 1) for b in byte_samples] Write Float Samples to WAV File def write_to_wav_file(filename, float_samples, nchannels=1, sampwidth=2, framerate=44100): def get_bytes(a_float): a_float = max(-1, min(1 - 2e-16, a_float)) a_float += sampwidth == 1 a_float *= pow(2, sampwidth * 8 - 1) return int(a_float).to_bytes(sampwidth, 'little', signed=sampwidth!=1) with wave.open(filename, 'wb') as file: file.setnchannels(nchannels) file.setsampwidth(sampwidth) file.setframerate(framerate) file.writeframes(b''.join(get_bytes(f) for f in float_samples)) Examples Saves a sine wave to a mono WAV file: from math import pi, sin samples_f = (sin(i * 2 * pi * 440 / 44100) for i in range(100000)) write_to_wav_file('test.wav', samples_f) Adds noise to a mono WAV file: from random import random add_noise = lambda value: value + (random() - 0.5) * 0.03 samples_f = (add_noise(f) for f in read_wav_file('test.wav')) write_to_wav_file('test.wav', samples_f) Plays a WAV file: # $ pip3 install simpleaudio from simpleaudio import play_buffer with wave.open('test.wav', 'rb') as file: p = file.getparams() frames = file.readframes(p.nframes) play_buffer(frames, p.nchannels, p.sampwidth, p.framerate) Text to Speech # $ pip3 install pyttsx3 import pyttsx3 engine = pyttsx3.init() engine.say('Sally sells seashells by the seashore.') engine.runAndWait() Synthesizer Plays Popcorn by Gershon Kingsley: # $ pip3 install simpleaudio import simpleaudio, math, struct from itertools import chain, repeat F = 44100 P1 = '71♪,69,,71♪,66,,62♪,66,,59♪,,,' P2 = '71♪,73,,74♪,73,,74,,71,,73♪,71,,73,,69,,71♪,69,,71,,67,,71♪,,,' get_pause = lambda seconds: repeat(0, int(seconds * F)) sin_f = lambda i, hz: math.sin(i * 2 * math.pi * hz / F) get_wave = lambda hz, seconds: (sin_f(i, hz) for i in range(int(seconds * F))) get_hz = lambda key: 8.176 * 2 ** (int(key) / 12) parse_note = lambda note: (get_hz(note[:2]), 0.25 if '♪' in note else 0.125) get_samples = lambda note: get_wave(*parse_note(note)) if note else get_pause(0.125) samples_f = chain.from_iterable(get_samples(n) for n in f'{P1}{P1}{P2}'.split(',')) samples_b = b''.join(struct.pack('&lt;h', int(f * 30000)) for f in samples_f) simpleaudio.play_buffer(samples_b, 1, 2, F) Pygame Basic Example # $ pip3 install pygame import pygame as pg pg.init() screen = pg.display.set_mode((500, 500)) rect = pg.Rect(240, 240, 20, 20) while all(event.type != pg.QUIT for event in pg.event.get()): deltas = {pg.K_UP: (0, -3), pg.K_RIGHT: (3, 0), pg.K_DOWN: (0, 3), pg.K_LEFT: (-3, 0)} for delta in (deltas.get(i) for i, on in enumerate(pg.key.get_pressed()) if on): rect = rect.move(delta) if delta else rect screen.fill((0, 0, 0)) pg.draw.rect(screen, (255, 255, 255), rect) pg.display.flip() Rect Object for storing rectangular coordinates. &lt;Rect&gt; = pg.Rect(x, y, width, height) &lt;int&gt; = &lt;Rect&gt;.x/y/centerx/centery &lt;tup.&gt; = &lt;Rect&gt;.topleft/center &lt;Rect&gt; = &lt;Rect&gt;.move((x, y)) &lt;bool&gt; = &lt;Rect&gt;.collidepoint((x, y)) # Tests if a point is inside a rectangle. &lt;bool&gt; = &lt;Rect&gt;.colliderect(&lt;Rect&gt;) # Tests if two rectangles overlap. &lt;int&gt; = &lt;Rect&gt;.collidelist(&lt;list_of_Rect&gt;) # Returns index of first colliding Rect or -1. &lt;list&gt; = &lt;Rect&gt;.collidelistall(&lt;list_of_Rect&gt;) # Returns indices of all colliding Rects. Surface Object for representing images. &lt;Surf&gt; = pg.display.set_mode((width, height)) # Returns the display surface. &lt;Surf&gt; = pg.Surface((width, height)) # Creates a new surface. &lt;Surf&gt; = pg.image.load('&lt;path&gt;') # Loads the image. &lt;Surf&gt; = &lt;Surf&gt;.subsurface(&lt;Rect&gt;) # Returns a subsurface. &lt;Surf&gt;.fill(color) # Fills the whole surface. &lt;Surf&gt;.set_at((x, y), color) # Updates pixel. &lt;Surf&gt;.blit(&lt;Surface&gt;, (x, y)) # Draws passed surface to the surface. &lt;Surf&gt; = pg.transform.flip(&lt;Surf&gt;, xbool, ybool) &lt;Surf&gt; = pg.transform.rotate(&lt;Surf&gt;, degrees) &lt;Surf&gt; = pg.transform.scale(&lt;Surf&gt;, (width, height)) pg.draw.line(&lt;Surf&gt;, color, (x1, y1), (x2, y2), width) pg.draw.arc(&lt;Surf&gt;, color, &lt;Rect&gt;, from_radians, to_radians) pg.draw.rect(&lt;Surf&gt;, color, &lt;Rect&gt;) pg.draw.polygon(&lt;Surf&gt;, color, points) pg.draw.ellipse(&lt;Surf&gt;, color, &lt;Rect&gt;) Font &lt;Font&gt; = pg.font.SysFont('&lt;name&gt;', size, bold=False, italic=False) &lt;Font&gt; = pg.font.Font('&lt;path&gt;', size) &lt;Surf&gt; = &lt;Font&gt;.render(text, antialias, color, background=None) Sound &lt;Sound&gt; = pg.mixer.Sound('&lt;path&gt;') # Loads the WAV file. &lt;Sound&gt;.play() # Starts playing the sound. Basic Mario Brothers Example import collections, dataclasses, enum, io, math, pygame, urllib.request, itertools as it from random import randint P = collections.namedtuple('P', 'x y') # Position D = enum.Enum('D', 'n e s w') # Direction SIZE, MAX_SPEED = 50, P(5, 10) # Screen size, Speed limit def main(): def get_screen(): pygame.init() return pygame.display.set_mode(2 * [SIZE*16]) def get_images(): url = 'https://gto76.github.io/python-cheatsheet/web/mario_bros.png' img = pygame.image.load(io.BytesIO(urllib.request.urlopen(url).read())) return [img.subsurface(get_rect(x, 0)) for x in range(img.get_width() // 16)] def get_mario(): Mario = dataclasses.make_dataclass('Mario', 'rect spd facing_left frame_cycle'.split()) return Mario(get_rect(1, 1), P(0, 0), False, it.cycle(range(3))) def get_tiles(): positions = [p for p in it.product(range(SIZE), repeat=2) if {*p} &amp; {0, SIZE-1}] + \\ [(randint(1, SIZE-2), randint(2, SIZE-2)) for _ in range(SIZE**2 // 10)] return [get_rect(*p) for p in positions] def get_rect(x, y): return pygame.Rect(x*16, y*16, 16, 16) run(get_screen(), get_images(), get_mario(), get_tiles()) def run(screen, images, mario, tiles): clock = pygame.time.Clock() while all(event.type != pygame.QUIT for event in pygame.event.get()): keys = {pygame.K_UP: D.n, pygame.K_RIGHT: D.e, pygame.K_DOWN: D.s, pygame.K_LEFT: D.w} pressed = {keys.get(i) for i, on in enumerate(pygame.key.get_pressed()) if on} update_speed(mario, tiles, pressed) update_position(mario, tiles) draw(screen, images, mario, tiles, pressed) clock.tick(28) def update_speed(mario, tiles, pressed): x, y = mario.spd x += 2 * ((D.e in pressed) - (D.w in pressed)) x = math.copysign(abs(x) - 1, x) if x else 0 y += 1 if D.s not in get_boundaries(mario.rect, tiles) else (-10 if D.n in pressed else 0) mario.spd = P(*[max(-thresh, min(thresh, s)) for thresh, s in zip(MAX_SPEED, P(x, y))]) def update_position(mario, tiles): old_p, delta = mario.rect.topleft, P(0, 0) larger_speed = max(abs(s) for s in mario.spd) for _ in range(int(larger_speed)): mario.spd = stop_on_collision(mario.spd, get_boundaries(mario.rect, tiles)) delta = P(*[a + s/larger_speed for a, s in zip(delta, mario.spd)]) mario.rect.topleft = [sum(pair) for pair in zip(old_p, delta)] def get_boundaries(rect, tiles): deltas = {D.n: P(0, -1), D.e: P(1, 0), D.s: P(0, 1), D.w: P(-1, 0)} return {d for d, delta in deltas.items() if rect.move(delta).collidelist(tiles) != -1} def stop_on_collision(spd, bounds): return P(x=0 if (D.w in bounds and spd.x &lt; 0) or (D.e in bounds and spd.x &gt; 0) else spd.x, y=0 if (D.n in bounds and spd.y &lt; 0) or (D.s in bounds and spd.y &gt; 0) else spd.y) def draw(screen, images, mario, tiles, pressed): def get_frame_index(): if D.s not in get_boundaries(mario.rect, tiles): return 4 return next(mario.frame_cycle) if {D.w, D.e} &amp; pressed else 6 screen.fill((85, 168, 255)) mario.facing_left = (D.w in pressed) if {D.e, D.w} &amp; pressed else mario.facing_left screen.blit(images[get_frame_index() + mario.facing_left*9], mario.rect) for rect in tiles: screen.blit(images[19 if {*rect.topleft} &amp; {0, (SIZE-1)*16} else 18], rect) pygame.display.flip() if __name__ == '__main__': main() Basic Script Template #!/usr/bin/env python3 # # Usage: .py # from collections import namedtuple from dataclasses import make_dataclass from enum import Enum from sys import argv import re def main(): pass ### ## UTIL # def read_file(filename): with open(filename, encoding='utf-8') as file: return file.readlines() if __name__ == '__main__': main() ","link":"https://IsumiAlice.github.io/post/kaqdpD-RS/"},{"title":"我在酒吧喝什麽","content":"記録一些喝過的酒，話說好久沒去酒吧了 伏特加基酒 黑俄羅斯 (伏特加、咖啡甜酒) 螺絲起子 (伏特加、橙汁) 柯夢波丹 (伏特加、白橙皮酒、蔓越莓汁) 威士忌基酒 威士忌酸 騷兒 (威士忌、萊姆汁) 威可 (威士忌、可樂) 古典鷄尾酒 Old Fashioned (威士忌、柑橘苦精、放糖、蘇打水) 蘭姆酒基酒 自由古巴 (蘭姆、可樂) 莫吉托 mojito i不發音 (蘭姆、檸檬、薄荷葉、蘇打水、糖) 白蘭地 Side Car 龍舌蘭 日出 瑪格麗特 ","link":"https://IsumiAlice.github.io/post/2LIiNoPRo/"},{"title":"柏拉圖多面體","content":"柏拉圖多面體 Platonic Polyhedra 並不是由柏拉圖所發明，但是卻是由柏拉圖及其追隨者對它們所作的研究而得名，由於它們具有高度的對稱性及次序感，因而通常被稱為正多面體。 柏拉圖多面體所有的面都是不自交、以直線段為邊長的正凸多邊形平面，每一種多面體都隻有一種正多邊形的表面，而且在每一個頂點處都有相同數目的面交會。不僅在每一個頂點處都有相同數目的面交會，而且在每一個頂點處所有交會的面的內角之總和會相等。 柏拉圖多面體的數量為五個 三維空間中的第六個柏拉圖多面體 Utah Teapot ! 更高維度的空間會怎樣呢？ 可以通過投影的方式將高維度空間的幾何形狀轉爲三維空間。 https://www.youtube.com/watch?v=2s4TqVAbfz4 其他的多面體 克蔔勒-Poinsot 多面體 Kepler-Poinsot Polyhedra 它們的面亦是相同的正多邊形, 但它們是凹多面體。 也叫做星形正多面體。 克蔔勒-Poinsot 多面體的數量為四個。 阿基米德立體 Archimedean Solid https://zh.wikipedia.org/wiki/%E9%98%BF%E5%9F%BA%E7%B1%B3%E5%BE%B7%E7%AB%8B%E9%AB%94 它們是以兩個或以上的正多邊形以相似的排列組成的凸多面體。 阿基米德立體都是「很對稱」的。 阿基米德立體的數量為 13 個。 ","link":"https://IsumiAlice.github.io/post/bo-la-tu-duo-mian-ti/"},{"title":"一道情人節的密碼題","content":"七夕快樂哦 今天是七夕呢，寫這個的起因是一個同學的女朋友發了個密碼解密給他。 這就是今天要解決的問題嘍，當然，先把兩種密碼的相關知識貼上。 凱撒密碼 在密碼學中，愷撒密碼（英語：Caesar cipher），或稱愷撒加密、愷撒變換、變換加密，是一種最簡單且最廣為人知的加密技術。它是一種替換加密的技術，明文中的所有字母都在字母表上向後（或向前）按照一個固定數目進行偏移後被替換成密文。例如，當偏移量是3的時候，所有的字母A將被替換成D，B變成E，以此類推。這個加密方法是以羅馬共和時期愷撒的名字命名的，當年愷撒曾用此方法與其將軍們進行聯繫。 愷撒密碼通常被作為其他更複雜的加密方法中的一個步驟，例如維吉尼亞密碼。愷撒密碼還在現代的ROT13系統中被應用。但是和所有的利用字母表進行替換的加密技術一樣，愷撒密碼非常容易被破解，而且在實際應用中也無法保證通信安全。 柵欄密碼 所謂柵欄密碼，就是把要加密的明文分成N個一組，然後把每組的第i個字連起來，形成一段無規律的話。 一般比較常見的是2欄的棚欄密碼。 比如明文：THERE IS A CIPHER 去掉空格後變為：THEREISACIPHER 兩個一組，得到：TH ER EI SA CI PH ER 先取出第一個字母：TEESCPE 再取出第二個字母：HRIAIHR 連在一起就是：TEESCPEHRIAIHR 這樣就得到我們需要的密碼了！ 而解密的時候，我們先吧密文從中間分開，變為兩行： T E E S C P E H R I A I H R 再按上下上下的順序組合起來： THEREISACIPHER 分出空格，就可以得到原文了： THERE IS A CIPHER Python 簡單實現 十幾行代碼，非常簡單。 後面的 for 循環部分應該還能再簡化一點。 import math inp = 'cvpgygppjvtgpgfgjgtq' num = -2 step1 = [chr(97 + (ord(x)-97+num)%26) for x in inp] print (step1) num2 = 3 num3 = math.ceil(len(step1)/num2) s2 = [step1[i*num3: (num3*(i+1)) if (num3*(i+1))&lt;len(step1) else len(step1)] for i in range(num2)] print(s2) s3 = [] for j in range(num3): for i in range(num2): try: s3.append(s2[i][j]) except: pass print (s3) ''' and then there were none ''' ","link":"https://IsumiAlice.github.io/post/yi-dao-qing-ren-jie-de-mi-ma-ti/"},{"title":"「北野武的小酒館」讀書筆記","content":"每個孩子都是優秀的，每個孩子都有無限的可能。 現在的成年人，都喜歡說這種癡人說夢式的廢話。 孩子怎麽可能都是優秀的？ 說得殘酷一點，笨孩子就是笨孩子。跑不快的孩子就是跑不快，你比如棒球吧，不管有多喜歡，不管練得多賣力，打不好的孩子就是打不好。 這種事情明擺著誰都知道，可有的大人呢，說什麽“只要你認真了，只要你努力了，就一定可以出人頭地”，說這種瞎話他們連眼睛都不眨一下。 但現實並非如此，只能說有才能的人付出了比常人更多的努力，這才終於成為人上人。難道說只要你接受了和一郎一樣的訓練，你就能像一郎那樣打球了嗎？ 戰後的民主主義什麽的，說人都是平等的。而這種平等，說到底只是法律框架下的平等，不管你是富人還是窮人，都受相同的法律的約束，都有最基本的人權，僅此而已。老實說，就連這種平等都不那麽靠譜，充其量只是一種冠冕堂皇的說辭而已。 可是，不少人誤解了，還以為真的人人平等呢。 哪怕說法律面前人人平等，也並不代表人就是平等的。 人的長相、身高體重、腦子裏裝的貨色，都是一人一個樣的。 你看看這個社會吧，既有靠路邊的野草勉強果腹的老夫妻，也有乘上自家的直升機只為了去外國吃一頓飯的大富豪。 就算你把腦子想爆了，人也不可能是平等的。可是呢，不知道什麽道理，人們都喜歡說“人是平等的”“只要努力了，就會有成績”這樣的話。 與對孩子說“你是個笨蛋”相比，這種話反而要殘酷得多。 只要努力就會有結果，我們不要再對孩子說這種假惺惺的話啦。我們應該從小就教育孩子要認清現實。人不是平等的，你沒有那種才能的。這是爹娘應該告訴孩子的現實。不管怎樣努力，做不到的事情就是做不到，這是爹娘必須教會孩子的。 告訴自己的孩子他沒有哪方面的才能，絕不是什麽殘酷的事。如果你覺得這麽說實在受不了，那就應該去幫助孩子獲得能夠在這個世界上安身立命的某種才能。 如果你的孩子沒有任何才能，那至少你應該培養他有一顆堅韌的心，這樣在他今後走上社會時哪怕被現實整得一塌糊塗、遍體鱗傷，他照樣還能活下去。 我們不應該畏懼讓孩子幼小的心靈受到傷害。讓孩子受傷害，讓他走投無路最後只得放棄，我覺得這樣反而更好。要得到自己想要的東西，就必須付出努力。但是，不管怎麽努力都得不到的，那就只有放棄。 這就是現實，應該從小就把這樣的教育註入孩子的骨髓裏去。 這就是身為人父的責任。 ","link":"https://IsumiAlice.github.io/post/bei-ye-wu-de-xiao-jiu-guan-du-shu-bi-ji/"},{"title":"使用 youtube-dl 下載影片","content":"youtube-dl常用命令 得到視頻可下載格式列表： youtube-dl -F [url] 下載相應的視頻、音頻並合併： youtube-dl -f 299+140 xxxxxx 自動選擇碼率最高的視頻下載： youtube-dl -f xxxxxx 下載播放隊列： youtube-dl -f 299+140 -o &quot;%(playlist_index)s-%(title)s.%(ext)s&quot; --playlist-start 18 --playlist-end 27 PLVTne6k3-60uJC9V8o3CmGjBj8XreCcqR 安裝 pip install --upgrade youtube-dl 在官方網站下載 ffmpeg，解壓縮 環境變數Path中添加ffmpeg\\bin ffmpeg -version VPS端(Linux)配置 安裝 youtube-dl sudo curl -L https://yt-dl.org/downloads/latest/youtube-dl -o /usr/local/bin/youtube-dl sudo chmod a+rx /usr/local/bin/youtube-dl 安裝 ffmpeg(稍稍稍稍複雜) 安裝 yasm $ tar -xvzf yasm-1.3.0.tar.gz $ cd yasm-1.3.0/ $ ./configure $ make $ make install 下載ffmpeg源碼，並傳入VPS $ tar -xjvf ffmpeg-3.3.1.tar.bz2 $ cd ffmpeg-3.3.1/ $ ./configure --enable-shared --prefix=/monchickey/ffmpeg $ make $ make install 配置一下 $ vi /etc/ld.so.conf.d/ffmpeg.conf 添加 /monchickey/ffmpeg/lib 保存退出 $ ldconfig $ cd /monchickey/ffmpeg/bin $ ./ffmpeg -version 可查看版本號 $ vi /etc/profile 末尾添加 export PATH=&quot;/monchickey/ffmpeg/bin:$PATH&quot; 保存退出 $ source /etc/profile 本地下載VPS上的文件 在VPS上開啟臨時HTTP服務器 $ python -m SimpleHTTPServer 本地瀏覽器打開 IP:8000 OK了，用瀏覽器愉快的下載相應文件吧 CTRL+C可關閉服務器 也可以netstat -anp | grep 8000查找相應進程如3333/python,然後通過kill -9 3333關閉進程 ","link":"https://IsumiAlice.github.io/post/shi-yong-youtube-dl-xia-zai-ying-pian/"},{"title":"本站搭建過程 Hexo","content":"安裝 安裝Node.js 更換爲國內源，安裝 cnpm $ npm config set registry https://registry.npm.taobao.org $ npm config get registry $ npm install -g cnpm $ cmpm install hexo 安裝Git 安裝Hexo $ npm install -g hexo-cli 建立 一旦 Hexo 完成後，請執行下列指令，Hexo 會在指定資料夾中建立所有您需要的檔案。 $ hexo init blog $ cd blog $ npm install 建立一篇新的文章 $ hexo new [layout] &lt;title&gt; 佈局 路徑 post source/_posts page source draft source/_drafts 產生靜態檔案 $ hexo generate 選項 描述 -d, --deploy 產生完成即部署網站 -w, --watch 監看檔案變更 啟動伺服器 預設為 http://localhost:4000/ $ hexo server 部署網站到Git 可以直接使用git命令部署，將 public 資料夾裏的文件複製到git目錄下，之後使用 git commit $ hexo generate $ git add . $ git commit -m &quot;update&quot; $ git push origin master Clean $ hexo clean 列出網站資料 $ hexo list &lt;type&gt; 顯示版本咨詢 $ hexo version 更換主題 在 themes 資料夾內，新增一個資料夾，並修改 _config.yml 內的 theme 設定，即可切換主題 渲染公式 更換 markdown 渲染引擎 npm uninstall hexo-renderer-marked --save npm install hexo-renderer-kramed --save 修改 node_modules/kramed/lib/rules/inline.js 注意註釋部分 var inline = { // escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_&gt;])/, escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/, autolink: /^&lt;([^ &gt;]+(@|:\\/)[^ &gt;]+)&gt;/, url: noop, html: /^&lt;!--[\\s\\S]*?--&gt;|^&lt;(\\w+(?!:\\/|[^\\w\\s@]*@)\\b)*?(?:&quot;[^&quot;]*&quot;|'[^']*'|[^'&quot;&gt;])*?&gt;([\\s\\S]*?)?&lt;\\/\\1&gt;|^&lt;(\\w+(?!:\\/|[^\\w\\s@]*@)\\b)(?:&quot;[^&quot;]*&quot;|'[^']*'|[^'&quot;&gt;])*?&gt;/, link: /^!?\\[(inside)\\]\\(href\\)/, reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/, nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/, reffn: /^!?\\[\\^(inside)\\]/, strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/, // em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/, br: /^ {2,}\\n(?!\\s*$)/, del: noop, text: /^[\\s\\S]+?(?=[\\\\&lt;!\\[_*`$]| {2,}\\n|$)/, math: /^\\$\\$\\s*([\\s\\S]*?[^\\$])\\s*\\$\\$(?!\\$)/, }; 在主題中開啓 mathjax 在 themes/xxx/_config.yml 一般 math: enable: true per_page: true engine: mathjax 在需要渲染公式的文章的 Fornt-matter 中打開 mathjax --- mathjax: true -- ","link":"https://IsumiAlice.github.io/post/hello-world/"}]}