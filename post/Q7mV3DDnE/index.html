<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>將藍噪聲用於光線追蹤的軟陰影 | 死体的部落格</title>
<link rel="shortcut icon" href="https://IsumiAlice.github.io/favicon.ico?v=1591530873066">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://IsumiAlice.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="將藍噪聲用於光線追蹤的軟陰影 | 死体的部落格 - Atom Feed" href="https://IsumiAlice.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="請以完整尺寸檢視上圖，噪點（尤其是藍噪聲）在較小的影象中會趨於消失
這篇文章中的原始碼在 shadertoy 中，可以通過下面的連結檢視完整程式碼Spherical Directional Light: https://www.shader..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://IsumiAlice.github.io">
  <img class="avatar" src="https://IsumiAlice.github.io/images/avatar.png?v=1591530873066" alt="">
  </a>
  <h1 class="site-title">
    死体的部落格
  </h1>
  <p class="site-description">
    
    <form id="gridea-search-form" data-update="1591530873066" action="/search/">
      <input name="q" />
    </form>
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首頁
        </a>
      
    
      
        <a href="/archives" class="menu">
          歸檔
        </a>
      
    
      
        <a href="/tags" class="menu">
          標籤
        </a>
      
    
      
        <a href="/post/about" class="menu">
          關於
        </a>
      
    
  </div>
  
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              將藍噪聲用於光線追蹤的軟陰影
            </h2>
            <div class="post-info">
              <span>
                2020-06-07
              </span>
              <span>
                11 min read
              </span>
              
            </div>
            
              <img class="post-feature-image" src="https://gitee.com/IsumiAlice/IsumiPic/raw/master///20200515204647.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1092150/1589984350158-fa9dced9-7316-4425-a693-0876acfc547e.png#align=left&amp;display=inline&amp;height=1199&amp;margin=%5Bobject%20Object%5D&amp;name=spot.png&amp;originHeight=1199&amp;originWidth=1919&amp;size=642523&amp;status=done&amp;style=none&amp;width=1919" alt="spot.png" loading="lazy"><br />請以完整尺寸檢視上圖，噪點（尤其是藍噪聲）在較小的影象中會趨於消失<br /><br>
<br />這篇文章中的原始碼在 shadertoy 中，可以通過下面的連結檢視完整程式碼<br />Spherical Directional Light: <a href="https://www.shadertoy.com/view/3sfBWs">https://www.shadertoy.com/view/3sfBWs</a><br />Spherical Positional Light: <a href="https://www.shadertoy.com/view/ts2BRh">https://www.shadertoy.com/view/ts2BRh</a><br />Spherical Spot Light: <a href="https://www.shadertoy.com/view/tsjfRh">https://www.shadertoy.com/view/tsjfRh</a><br /><br>
<br />藍噪聲的一個有趣用法是用在光追的軟陰影上。軟陰影是指從區域光源獲得的陰影，而不是從點光源或定向光獲得的硬陰影。軟陰影具有半影 penumbra – 柔和的邊緣從全陰影過渡到全光照，如下圖所示。<br /><br>
<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1092150/1589984751279-9488bf15-83b8-470d-aaca-20b48e889cd3.jpeg#align=left&amp;display=inline&amp;height=2952&amp;margin=%5Bobject%20Object%5D&amp;name=img_20170625_102923436_hdr.jpg&amp;originHeight=2952&amp;originWidth=5248&amp;size=6348448&amp;status=done&amp;style=none&amp;width=5248" alt="img_20170625_102923436_hdr.jpg" loading="lazy"><br /><br>
<br />那麼我們如何使用藍噪聲呢？我們將首先從球形定向光源開始，然後將其擴充到球形位置光源，然後再擴充到球形聚光燈上。<br>
<a name="Yl4Hc"></a></p>
<h2 id="spherical-directional-light-white-noise">Spherical Directional Light: White Noise</h2>
<p><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1092150/1589984891630-c08c24e6-082e-4cee-9ffc-07d824f65bca.png#align=left&amp;display=inline&amp;height=1193&amp;margin=%5Bobject%20Object%5D&amp;name=directional.png&amp;originHeight=1193&amp;originWidth=1916&amp;size=331360&amp;status=done&amp;style=none&amp;width=1916" alt="directional.png" loading="lazy"><br /><br>
<br />定向光是從特定方向發出的光，不論您在世界上的什麼位置。<br />光源位置是如此遙遠，以至於您所做的任何移動（平移）都不會顯著改變您對光源的相對位置。想象一下太陽。<br /><br>
<br />對於這樣的光源，raytracing a shadow 只需要朝著太陽發射光線，檢查其是否碰到任何幾何形狀。如果碰到任何東西，則射線的原點在陰影中。如果沒有擊中，則該點被照亮。答案是非 0 即 1 的，因此陰影邊緣很 hard。沒有半影。<br /><br>
<br />這種模型的問題在於，從我們的角度來看，太陽實際上是一個圓時，而我們卻將其視為天空中的無限小點。它實際上是一個球體（或足夠接近球體），但是其「立體角」的二維投影是一個圓。<br /><br>
<br />因此，要獲得更逼真的照明和陰影，不是在空間中的單個微小點上發射光線，而是需要檢視射線的原點是否可以看到作為球形光源的圓，更重要的是，我們需要知道可以看到的圓的大小。<br /><br>
<br />數學上的解釋是，我們需要對圓的可見性進行積分，但是由於我們的場景不太可能得到一個閉合形式的方程，因此，我們需要採用數值方法並在圓上進行取樣以獲得陰影項。<br /><br>
<br />拋開數學，用簡單一點的人話來解釋就是，我們希望發射多條光線到圓上的幾個位置隨機，並得到能夠看到該圓的光線數量的百分比。我們將亮度乘以該百分比，就可以獲得柔和的陰影。<br /><br>
<br />好吧，現在我們知道我們需要做什麼了，我們該怎麼做呢？<br /><br>
<br />因此，首先，我們需要生成一個「圓上的均勻點」，圓上的每個點均可能被選擇。因此我們可以使用兩個從 0 到 1 的均勻分佈的隨機數來選擇這些點，一般的 shader hash function 或 shader rng function 都可以做到這一點，我喜歡使用「無正弦哈希」函式</p>
<pre><code class="language-c">float pointRadius = c_lightRadius * sqrt(rng.x);
float pointAngle = rng.y * 2.0f * c_pi;
diskPoint = vec2(pointRadius*cos(pointAngle), pointRadius*sin(pointAngle));
</code></pre>
<p><br />注意上面的 c_lightRadius。該值是天空中圓的感知大小，我使用的值為 0.1。<br /><br>
<br />因此，現在我們在圓上有均勻的隨機點了，接下來該如何處理呢？要使其成為太陽上的實際點，我們需要一個座標系以將該圓放入其中。<br /></p>
<pre><code class="language-c">vec3 lightTangent = normalize(cross(c_lightDir, vec3(0.0f, 1.0f, 0.0f)));
vec3 lightBitangent = normalize(cross(lightTangent, c_lightDir));
</code></pre>
<p><br />現在是射線射向的世界空間的時候了，計算射線方向：<br /></p>
<pre><code class="language-c">vec3 rayTarget = rayPos + c_lightDir + diskPoint.x * lightTangent + diskPoint.y * lightBitangent;
vec3 shadowRayDir = normalize(rayTarget - rayPos);
</code></pre>
<p><br />執行此操作，會得到一個半影。這就是「White Noise Raw」的影象，每個畫素計算 16 條陰影射線。<br /><br>
<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1092150/1589985194448-1c8023fe-85a8-4f00-88bb-73db21ac3072.png#align=left&amp;display=inline&amp;height=596&amp;margin=%5Bobject%20Object%5D&amp;name=dirwhiteraw.png&amp;originHeight=596&amp;originWidth=954&amp;size=72522&amp;status=done&amp;style=none&amp;width=954" alt="dirwhiteraw.png" loading="lazy"><br>
<a name="3Jmgu"></a></p>
<h2 id="spherical-directional-light-blue-noise-over-space-low-discrepancy-over-time">Spherical Directional Light: Blue Noise Over Space, Low Discrepancy Over Time</h2>
<p><br />作為藍噪聲狂熱者，我討厭白噪聲，而且我知道如果可以用白噪聲，那麼幾乎可以肯定，使用藍噪聲或低差異序列可以取得更好的結果。<br /><br>
<br />實際上，我們將以兩種不同的方式使用藍噪聲來改善陰影。第一種方法是，不是在圓上使用白噪聲 (uncorrelated) 均勻分佈隨機數，而是在圓上使用藍噪聲 (negatively correlated) 均勻分佈隨機數。<br /><br>
<br />白噪聲會聚在一起，形成半冗餘的樣本，並且在樣本之間還會留下較大的孔，從而形成較大的未知區域。而藍噪聲雖然是隨機的，但取樣間隔大致均勻。<br /><br>
<br />我使用 mitchell 的最佳候選演算法生成藍噪聲，以下是我生成的點列表。這些藍噪聲點是漸進的，這意味著如果您使用第一個 N，則無論 N 是多少，都會產生藍噪聲。因此，支援 64 或更少的樣本數。<br /></p>
<pre><code class="language-c">const vec2 BlueNoiseInDisk[64] = vec2[64](
    vec2(0.478712,0.875764),
    vec2(-0.337956,-0.793959),
    vec2(-0.955259,-0.028164),
    vec2(0.864527,0.325689),
    vec2(0.209342,-0.395657),
    vec2(-0.106779,0.672585),
    vec2(0.156213,0.235113),
    vec2(-0.413644,-0.082856),
    vec2(-0.415667,0.323909),
    vec2(0.141896,-0.939980),
    vec2(0.954932,-0.182516),
    vec2(-0.766184,0.410799),
    vec2(-0.434912,-0.458845),
    vec2(0.415242,-0.078724),
    vec2(0.728335,-0.491777),
    vec2(-0.058086,-0.066401),
    vec2(0.202990,0.686837),
    vec2(-0.808362,-0.556402),
    vec2(0.507386,-0.640839),
    vec2(-0.723494,-0.229240),
    vec2(0.489740,0.317826),
    vec2(-0.622663,0.765301),
    vec2(-0.010640,0.929347),
    vec2(0.663146,0.647618),
    vec2(-0.096674,-0.413835),
    vec2(0.525945,-0.321063),
    vec2(-0.122533,0.366019),
    vec2(0.195235,-0.687983),
    vec2(-0.563203,0.098748),
    vec2(0.418563,0.561335),
    vec2(-0.378595,0.800367),
    vec2(0.826922,0.001024),
    vec2(-0.085372,-0.766651),
    vec2(-0.921920,0.183673),
    vec2(-0.590008,-0.721799),
    vec2(0.167751,-0.164393),
    vec2(0.032961,-0.562530),
    vec2(0.632900,-0.107059),
    vec2(-0.464080,0.569669),
    vec2(-0.173676,-0.958758),
    vec2(-0.242648,-0.234303),
    vec2(-0.275362,0.157163),
    vec2(0.382295,-0.795131),
    vec2(0.562955,0.115562),
    vec2(0.190586,0.470121),
    vec2(0.770764,-0.297576),
    vec2(0.237281,0.931050),
    vec2(-0.666642,-0.455871),
    vec2(-0.905649,-0.298379),
    vec2(0.339520,0.157829),
    vec2(0.701438,-0.704100),
    vec2(-0.062758,0.160346),
    vec2(-0.220674,0.957141),
    vec2(0.642692,0.432706),
    vec2(-0.773390,-0.015272),
    vec2(-0.671467,0.246880),
    vec2(0.158051,0.062859),
    vec2(0.806009,0.527232),
    vec2(-0.057620,-0.247071),
    vec2(0.333436,-0.516710),
    vec2(-0.550658,-0.315773),
    vec2(-0.652078,0.589846),
    vec2(0.008818,0.530556),
    vec2(-0.210004,0.519896) 
);
</code></pre>
<p><br />使用上述更改，我們就會得到以下奇怪的結果：<br /><br>
<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1092150/1589985350294-e398b9ee-4a64-4e1e-9b61-dc17b6c1fe63.png#align=left&amp;display=inline&amp;height=596&amp;margin=%5Bobject%20Object%5D&amp;name=bluebad.png&amp;originHeight=596&amp;originWidth=956&amp;size=47554&amp;status=done&amp;style=none&amp;width=956" alt="bluebad.png" loading="lazy"><br /><br>
<br />問題在於，每個畫素都使用相同的藍噪聲取樣序列，並且只有 16 個取樣。這意味著每個球體基本上都有 16 個重疊陰影。藍噪聲做得很好，因為這些陰影彼此之間有很大的不同，但是陰影還不夠好。<br /><br>
<br />現在我們需要引入第二個藍噪聲。我們將在螢幕空間中平鋪藍色噪聲紋理（<a href="http://momentsingraphics.de/BlueNoise.html">http://momentsingraphics.de/BlueNoise.html</a>），以便我們可以獲取每個畫素的「藍色噪聲隨機值」，該值介於 0 1 之間，我們將這個值乘以 2 * pi 並將其用作旋轉 2d 藍噪聲樣本的 <strong>角度</strong>。<br /><br>
<br />每個畫素將具有不同的旋轉量，並且每個畫素將使用與相鄰畫素的旋轉不同的旋轉，這是藍噪聲的性質決定的。<br /><br>
<br />此處的一個不錯的優化是，對一個畫素來說，所有樣本旋轉相同的量，因此可以在雙重迴圈外計算餘弦和正弦，並在雙重迴圈內重複使用它們。<br /><br>
<br />我們最終得到右側的影象。將其與左側進行比較，很容易發現藍噪聲的好。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1092150/1589985412681-0487b4b3-4d35-4a58-bf0b-438f66f15b97.png#align=left&amp;display=inline&amp;height=596&amp;margin=%5Bobject%20Object%5D&amp;name=dirwhitevsblue.png&amp;originHeight=596&amp;originWidth=1915&amp;size=114316&amp;status=done&amp;style=none&amp;width=1915" alt="dirwhitevsblue.png" loading="lazy"><br /><br>
<br />不過，還沒有完成……我們還需要考慮時間（抗鋸齒），才可以宣佈勝利。<br /><br>
<br />在藍噪聲值上新增 frameNumber * goldenRatio 使其回到 0 到 1 的範圍，在乘以 2 * pi 之前進行此操作。<br /><br>
<br />如果這樣做，隨著時間的推移，每個畫素的藍噪聲值將變為低差異序列。它會稍微影響我們在空間上的藍噪聲，但這是淨贏 net win。<br /><br>
<br />這使畫素在時間上更穩定，這對於 TAA 和其他時間濾波/累積方法非常有用，但是即使在不進行時間濾波的情況下也是更好的。您可以在著色器中開啟和關閉 ANIMATE_NOISE 定義。<br /><br>
<br />最終結果<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1092150/1589985524714-8010e5f2-2aa2-4e92-a000-d9c6ba9e47fd.png#align=left&amp;display=inline&amp;height=1193&amp;margin=%5Bobject%20Object%5D&amp;name=directional%20%281%29.png&amp;originHeight=1193&amp;originWidth=1916&amp;size=331360&amp;status=done&amp;style=none&amp;width=1916" alt="directional (1).png" loading="lazy"><br /><br>
<br />順便說一句，當噪聲與周圍的事物形成鮮明對比時，噪聲會更加明顯。例如，這裡的影象與上面的影象相同，但是環境光的亮度是 10 倍，就很難看到噪點了，甚至白噪聲都不太明顯的樣子。<br /><br>
<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1092150/1589985554578-faff11d1-f6d0-4591-a199-1157f777f1de.png#align=left&amp;display=inline&amp;height=1199&amp;margin=%5Bobject%20Object%5D&amp;name=dirbright.png&amp;originHeight=1199&amp;originWidth=1919&amp;size=226133&amp;status=done&amp;style=none&amp;width=1919" alt="dirbright.png" loading="lazy"><br /></p>
<p><a name="PVZKJ"></a></p>
<h2 id="spherical-positional-light">Spherical Positional Light</h2>
<p><br />解釋了球形定向燈後，最困難的部分就完成了！<br /><br>
<br />您只需對程式碼進行 2 處修改，即可從球形定向燈更改為球形位置燈。<br /><br>
<br />第一個變化是，都使用 c_lightDir 常數，而應使用從被陰影畫素指向光源位置（光源中心）的歸一化向量。<br /><br>
<br />第二個變化是 c_lightRadius 也不再是常數。與太陽不同，不同位置看到的球形位置燈會改變大小。隨著您離燈越來越遠，該燈的 2d 投影圓變得越來越小。當您靠近時，則會變大。<br /><br>
<br />公式實際上非常簡單。如果 c_lightRadius 是球體的半徑，考慮是從陰影畫素到光源中心的距離 dist，使用 c_lightRadius/dist 即可。<br /><br>
<br />進行這些更改，可以得到：<br /><br>
<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1092150/1589985644320-48438668-6a1e-4214-a284-7e56e9de3ba9.png#align=left&amp;display=inline&amp;height=1199&amp;margin=%5Bobject%20Object%5D&amp;name=positional.png&amp;originHeight=1199&amp;originWidth=1920&amp;size=585807&amp;status=done&amp;style=none&amp;width=1920" alt="positional.png" loading="lazy"><br>
<a name="mHykg"></a></p>
<h2 id="spherical-spot-light">Spherical Spot Light</h2>
<p><br />現在有了球形的位置燈，將其修改為球形的聚光燈非常容易。<br /><br>
<br />首先要做的是重新引入光的方向，也就是聚光燈發出光的方向。我們將對光源到畫素的向量與光線的向量進行點積，以瞭解畫素與光線的夾角，從而確定畫素是否在光圓錐體中。<br /><br>
<br />接下來要做的是定義 cosine theta inner 和 cosine theta outer，當點積小於 cosine theta outer 時，則沒有光。如果大於 cosine theta inner，則為全光照。在這些值之間，我們希望它從亮變為不亮，為此，我喜歡使用平滑步長進行非線性淡入：</p>
<pre><code class="language-c">vec3 lightDir = normalize(c_lightPos - hitPos);
float angleAtten = dot(lightDir, -c_lightDir);
angleAtten = smoothstep(c_cosThetaOuter, c_cosThetaInner, angleAtten);
lightColor *= angleAtten;
</code></pre>
<p><br />最終的結果：<br /><br>
<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1092150/1589985718522-8a4f8498-80b0-48fd-8036-8075b1965e34.png#align=left&amp;display=inline&amp;height=1199&amp;margin=%5Bobject%20Object%5D&amp;name=spot%20%281%29.png&amp;originHeight=1199&amp;originWidth=1919&amp;size=642523&amp;status=done&amp;style=none&amp;width=1919" alt="spot (1).png" loading="lazy"><br /><br>
<br /><a href="https://blog.demofox.org/2020/05/16/using-blue-noise-for-raytraced-soft-shadows/">https://blog.demofox.org/2020/05/16/using-blue-noise-for-raytraced-soft-shadows/</a></p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#spherical-directional-light-white-noise">Spherical Directional Light: White Noise</a></li>
<li><a href="#spherical-directional-light-blue-noise-over-space-low-discrepancy-over-time">Spherical Directional Light: Blue Noise Over Space, Low Discrepancy Over Time</a></li>
<li><a href="#spherical-positional-light">Spherical Positional Light</a></li>
<li><a href="#spherical-spot-light">Spherical Spot Light</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://IsumiAlice.github.io/post/koJCJJ3ay/">
              <h3 class="post-title">
                Arm Performance Libraries 環境配置
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://IsumiAlice.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
